<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 核心技术</title>
      <link href="/2021/01/22/Docker/Docker%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/01/22/Docker/Docker%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。<br><a id="more"></a></p><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><blockquote><p><strong>环境准备</strong></p></blockquote><ol><li>CentOS 7</li><li>Mac 使用 SSH Shell，Windows 使用 XShell 连接远程服务器</li></ol><blockquote><p><strong>环境查看</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 系统内核在 3.10 以上</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# uname -r                                                                                </span><br><span class="line">3.10.0-957.21.3.el7.x86_64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 系统版本</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# cat /etc/os-release   </span><br><span class="line">NAME="CentOS Linux"                             </span><br><span class="line">VERSION="7 (Core)"                              </span><br><span class="line">ID="centos"                                      </span><br><span class="line">ID_LIKE="rhel fedora"                              </span><br><span class="line">VERSION_ID="7"                                 </span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"              </span><br><span class="line">ANSI_COLOR="0;31"                               </span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"                 </span><br><span class="line">HOME_URL="https://www.centos.org/"             </span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"               </span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"                                         </span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"                                       </span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"                                           </span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure><blockquote><p><strong>Docker 容器引擎的安装部署</strong></p></blockquote><h3 id="1-CentOS-安装-Docker"><a href="#1-CentOS-安装-Docker" class="headerlink" title="1. CentOS 安装 Docker"></a>1. CentOS 安装 Docker</h3><ol><li><p>yum 包更新到最新<br><code>yum update</code></p></li><li><p>卸载旧版本<br>旧版本 <code>Docker</code> 称为 <code>docker</code> 或者  <code>docker-engine</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-selinux \</span><br><span class="line">                 docker-engine-selinux \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure></li><li><p>设置存储库<br><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p></li><li><p>设置yum源为阿里云<br><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p></li><li><p>安装 Docker<br><code>yum install docker-ce -y</code><br>查看下载的文件<br><code>yum list installed | grep docker</code></p></li><li><p>启动 Docker<br><code>systemctl start docker</code><br>验证有没有启动成功<br><code>docker images</code></p></li><li><p>配置阿里云配置镜像加速器<br>容器镜像服务 - 镜像加速器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://0zi6sztb.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Docker-UI-Portainer"><a href="#2-Docker-UI-Portainer" class="headerlink" title="2. Docker UI: Portainer"></a>2. Docker UI: Portainer</h3><ol><li><p>选择镜像 下载</p><p><code>docker pull docker.io/portainer/portainer</code></p></li><li><p>查看容器<br><code>docker ps -a</code></p></li><li><p>启动UI</p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210125133236973.png" alt="image-20210125133236973"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d </span><br><span class="line">           -p 9000:9000 </span><br><span class="line">           --restart=always </span><br><span class="line">           -v /var/run/docker.sock:/var/run/docker.sock </span><br><span class="line">           --name prtainer-arry </span><br><span class="line">           portainer/portainer</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>打开 Docker 可视化页面<br><code>http://服务器ip:9000</code></li></ol><h3 id="3-Tomcat-项目发布"><a href="#3-Tomcat-项目发布" class="headerlink" title="3. Tomcat 项目发布"></a>3. Tomcat 项目发布</h3><p>安装包可在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 查看</p><ol><li><p>下载 tomcat</p><p><code>docker pull tomcat:8.5.54-jdk8-openjdk</code></p></li><li><p>创建一个守护式容器：如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器（容器名称不能重复）<br><code>docker run -d --name=tomcat-8080 -p 8080:8080 -v /usr/local/webapps/:/usr/local/tomcat/webapps/ tomcat:8.5.54-jdk8-openjdk</code></p></li></ol><h3 id="4-Node-js-项目发布"><a href="#4-Node-js-项目发布" class="headerlink" title="4. Node.js 项目发布"></a>4. Node.js 项目发布</h3><ol><li>在Dockerfile文件所在目录下运行以下命令构建一个Image<br><code>docker build -t [镜像名称] .</code></li><li>运行镜像<br><code>docker run -d -p 8888:8888 [镜像名称]</code></li></ol><p><a href="https://www.cnblogs.com/li-peng/p/5827104.html" target="_blank" rel="noopener">https://www.cnblogs.com/li-peng/p/5827104.html</a></p><h3 id="5-底层原理"><a href="#5-底层原理" class="headerlink" title="5. 底层原理"></a>5. 底层原理</h3><blockquote><p><strong>Docker 是怎么工作的</strong></p></blockquote><p>Docker 是一个 Client - Server 结构的系统，Docker 的守护进程运行在主机上，通过 Socket 从客户端访问。</p><p>DockerServer 接收到 Docker-Client 的指令，就会执行这个命令。</p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210128130324266.png" alt="image-20210128130324266"></p><h2 id="Docker-常用指令"><a href="#Docker-常用指令" class="headerlink" title="Docker 常用指令"></a>Docker 常用指令</h2><h3 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1. 帮助命令"></a>1. 帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version# 显示 docker 的版本信息</span><br><span class="line">docker info# 显示 docker 的系统信息</span><br><span class="line">docker 命令 --help# 帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档地址：<a href="https://docs.docker.com/reference/" target="_blank" rel="noopener">https://docs.docker.com/reference/</a></p><h3 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h3><p><strong>docker images 查看所有本地主机上的镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker images                                </span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED        SIZE            </span><br><span class="line">node-14.15.3-api      latest    18caeda5bf31   2 days ago     958MB             </span><br><span class="line">node                  14.15.3   72aaced1868f   5 weeks ago    942MB           </span><br><span class="line">portainer/portainer   latest    62771b0b9b09   6 months ago   79.1MB  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> repository 镜像的仓库源</span><br><span class="line"><span class="meta">#</span> 可选项</span><br><span class="line">--all , -a# 列出所有镜像</span><br><span class="line">--quiet , -q# 只显示镜像ID</span><br></pre></td></tr></table></figure><p><strong>docker search 搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker search mongodb                                                                                                  </span><br><span class="line">NAME                                DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED                                       </span><br><span class="line">mongo                               MongoDB document databases provide high avai…   7489      [OK]                                                       </span><br><span class="line">mongo-express                       Web-based MongoDB admin interface, written w…   859       [OK]         </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可选项 通过收藏数来过滤</span><br><span class="line">--filter=STARS=3000 # 搜索 STARS 大于3000的镜像</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker search mongodb --filter=STARS=3000                                                                              </span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED                                                                 </span><br><span class="line">mongo     MongoDB document databases provide high avai…   7489      [OK]</span><br></pre></td></tr></table></figure><p><strong>docker pull 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker pull mongo-express</span><br><span class="line">Using default tag: latest   # 如果不写 tag，默认下载最新的 latest</span><br><span class="line">latest: Pulling from library/mongo-express</span><br><span class="line">0a6724ff3fcd: Pull complete    # 分层下载，docker image 的核心  联合文件系统</span><br><span class="line">5fd2bdfdbf4b: Pull complete</span><br><span class="line">80b224d472a8: Pull complete</span><br><span class="line">e21405c347ae: Pull complete</span><br><span class="line">14277cdfbd7c: Pull complete</span><br><span class="line">7ff6a1594a5c: Pull complete</span><br><span class="line">e7203c023e57: Pull complete</span><br><span class="line">8f751d814fa1: Pull complete</span><br><span class="line">Digest: sha256:6ae44c697cd2381772f8ea8f0571008b62e36301305b113df7f35f2e683e8255    # 签名                                                    </span><br><span class="line">Status: Downloaded newer image for mongo-express:latest</span><br><span class="line">docker.io/library/mongo-express:latest   # 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 等价的</span><br><span class="line">docker pull mongo-express</span><br><span class="line">docker pull docker.io/library/mongo-express:latest</span><br></pre></td></tr></table></figure><p><strong>docker rmi 删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 删除指定id的镜像</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker rmi -f 容器ID</span><br><span class="line"><span class="meta">#</span> 删除多个容器</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker rmi -f 容器ID 容器ID 容器ID</span><br><span class="line"><span class="meta">#</span> 删除全部的容器</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure><h3 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h3><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] [镜像名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 参数说明</span><br><span class="line">--name=Name# 容器名字，用来区分容器</span><br><span class="line">-d# 后台方式运行</span><br><span class="line">-it# 使用交互方式运行，进入容器内部</span><br><span class="line">-p# 指定容器的端口 -p 8080:8080</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口 （常用）</span><br><span class="line">-p 容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P# 随机指定端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 测试，启动并进入容器</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -it centos</span><br><span class="line">[root@a98c171a363f /]#</span><br></pre></td></tr></table></figure><p><strong>列出所有的运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker ps 命令</span><br><span class="line"><span class="meta">#</span> 列出当前正在运行的容器</span><br><span class="line">-a # 列出当前正在运行的容器 + 历史运行过的容器</span><br><span class="line">-n=?# 显示最近创建的容器</span><br><span class="line">-q# 只显示容器的编号</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker ps -aq</span><br><span class="line">68135a1d62ae</span><br><span class="line">a98c171a363f</span><br><span class="line">304e49e0ed96</span><br><span class="line">4935571ec2c6</span><br><span class="line">8bf9e5273298</span><br></pre></td></tr></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit# 直接退出容器</span><br><span class="line">Ctrl + P + Q# 容器不停止退出</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id# 删除容器，不能删除正在运行的容器，强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)# 删除所有的容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器的操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id # 重启容器</span><br><span class="line">docker stop 容器id# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure><h3 id="4-常用的其他命令"><a href="#4-常用的其他命令" class="headerlink" title="4. 常用的其他命令"></a>4. 常用的其他命令</h3><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker run -d 镜像名</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -d centos                                                                                                                         </span><br><span class="line">3c59f35473e920a93f87edc3ac1b803a26572ebdbeac6ecf67b47c643d64cb5f                                          </span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span> 问题：docker ps，发现 centos 停止了</span><br><span class="line"><span class="meta"> #</span> 常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止</span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker logs -f -t --tail 10 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果没有日志，编写一段shell脚本</span><br><span class="line"><span class="meta">#</span> docker run -d centos /bin/sh -c "while true;do echo guoxiaobo;sleep 2;done"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示日志</span><br><span class="line">-t -f# -t：显示日志 -f：加上时间戳（可以写成 -tf）</span><br><span class="line">--tail number# 显示指定条数的日志</span><br></pre></td></tr></table></figure><p><strong>查看容器中进程信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker top 容器id</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker top 17135743dc7c                                                                                                                      </span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                29534               29515               0                   22:10               ?                   00:00:00            /bin/sh -c while true;do echo guoxiaobo;sleep 2;done</span><br><span class="line">root                29820               29534               0                   22:16               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2</span><br></pre></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker inspect 17135743dc7c</span><br></pre></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 我们通常容器都是后台方式运行的，需要进入容器，修改一些配置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 方式一：进入容器</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker exec -it 17135743dc7c /bin/bash</span><br><span class="line">[root@17135743dc7c /]# ps -ef# 用标准的格式显示进程                                                           </span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD                                                                                                                            </span><br><span class="line">root         1     0  0 14:10 ?        00:00:00 /bin/sh -c while true;do echo guoxiaobo;sleep 2;done                                                                           </span><br><span class="line">root      1854     0  0 15:11 pts/0    00:00:00 /bin/bash                                                                                                                      </span><br><span class="line">root      1908     1  0 15:13 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2                                                             </span><br><span class="line">root      1909  1854  0 15:13 pts/0    00:00:00 ps -ef    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 方式二</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker attach 17135743dc7c                                                                                                                   </span><br><span class="line">guoxiaobo                                                                                                                                                                      </span><br><span class="line">guoxiaobo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker exec# 进入容器后开启一个新的终端，可以在里面操作（常用）</span><br><span class="line"><span class="meta">#</span> docker attach# 进入容器正在执行的终端，不会启动新的进程</span><br></pre></td></tr></table></figure><p><strong>从容器内拷贝文件到主机上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内文件路径 目的主机路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 拷贝是一个手动的过程，后面通过 -v 卷技术，可以实现自动同步</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>Docker 安装 Nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker pull nginx 下载镜像</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行镜像</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -d --name=nginx01 -p 3344:80 nginx  </span><br><span class="line">1747791356e881a4ccc3d95d0e404faf0fac0ff2bc0fa1d521769cf6ceb59dcf </span><br><span class="line"><span class="meta">#</span> 本地测试</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# curl localhost:3344                 </span><br><span class="line">&lt;!DOCTYPE html&gt;                                 </span><br><span class="line">&lt;html&gt;                                                                                                                    </span><br><span class="line">&lt;head&gt;                                                                                                                    </span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;                                                                                          </span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Docker 安装 Tomcat</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 官方的使用</span><br><span class="line">docker run -it -rm tomcat:9.0# 用完即删除镜像</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 正常使用</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -d -p 3004:8080 --name=tomcat01 tomcat</span><br></pre></td></tr></table></figure><h2 id="Docker-镜像操作"><a href="#Docker-镜像操作" class="headerlink" title="Docker 镜像操作"></a>Docker 镜像操作</h2><p><strong>commit 镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit # 提交容器成为一个新的镜像</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 命令和git原理类似</span><br><span class="line">docker commit -m="描述信息" -a="作者" [容器id] [目标镜像名:tag]</span><br></pre></td></tr></table></figure><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>容器之间有一个数据共享的技术！Docker 容器中产生的数据，同步到本地！这种技术就是卷技术！</p><p>实现目录的挂载，将我们容器的目录挂载到 Linux 上。</p><blockquote><p><strong>方式一：使用命令的方式来挂载 -v</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录 镜像名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动之后，可以通过 docker inspect 容器id 查看</span><br></pre></td></tr></table></figure><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210129202136445.png" alt="image-20210129202136445"></p><h3 id="安装-MySql"><a href="#安装-MySql" class="headerlink" title="安装 MySql"></a>安装 MySql</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取镜像</span><br><span class="line"><span class="meta">#</span> docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行容器，需要配置密码</span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 命名</span><br><span class="line"><span class="meta">#</span> docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql_bind mysql:5.7         </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 假设将容器删除，我们挂载到本地的数据库文件依旧存在，这就实现了容器数据持久化！</span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 匿名挂载</span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看所有的卷情况</span><br><span class="line"><span class="meta">#</span> docker volume ls</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z home]# docker volume ls                                                                                                                                                     </span><br><span class="line">DRIVER    VOLUME NAME                                                                                                                                                                                     </span><br><span class="line">local     36fcaf3e61ecd79c39148fe669ce5c8355a4e55a4caf9476f8e224f3920e4791      # 匿名</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 具名挂载</span><br><span class="line">-v 名字:容器内路径</span><br><span class="line"><span class="meta">#</span> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z home]# docker volume ls        </span><br><span class="line">DRIVER    VOLUME NAME                                                                                                                                </span><br><span class="line">local     juming-nginx  # 具名</span><br><span class="line"><span class="meta">#</span> 查看卷的具体信息</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z home]# docker volume inspect juming-nginx                            </span><br><span class="line">[                                                                                                                                                                                                         </span><br><span class="line">    &#123;                                                                                                                                                                                                     </span><br><span class="line">        "CreatedAt": "2021-01-30T08:51:11+08:00",       </span><br><span class="line">        "Driver": "local",        </span><br><span class="line">        "Labels": null,                                                                                             </span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",  </span><br><span class="line">        "Name": "juming-nginx",  </span><br><span class="line">        "Options": null,        </span><br><span class="line">        "Scope": "local"      </span><br><span class="line">    &#125;                                                                                                                                                                                                     </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所有的 docker 容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code></p><p>大多数情况，我们使用 <code>具名挂载</code></p><p>拓展：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ro # 只读，说明这个路径只能通过宿主机来操作，容器内部是无法操作的</span><br><span class="line">rw # 只写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 一旦设置了容器权限，容器对我们挂载出来的内容就有限定了</span><br><span class="line"><span class="meta">#</span> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx</span><br></pre></td></tr></table></figure><h3 id="初识-Dockerfile"><a href="#初识-Dockerfile" class="headerlink" title="初识 Dockerfile"></a>初识 Dockerfile</h3><blockquote><p><strong>方式二：编写 dockerfile 文件挂载</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个 dockerfile 文件，文件内的一条指令对应镜像的一层</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z docker-file-test]# vim dockerfile1                                                                                                                                          </span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z docker-file-test]# cat dockerfile1                                                                                                                                          </span><br><span class="line">FROM centos    # 镜像基于 centos                                                                                                                                                                                           </span><br><span class="line">                                                                                                                                                                                                          </span><br><span class="line">VOLUME ["volume01", "volume02"]       # 挂载                                                                                                                                                                    </span><br><span class="line">                                                                                                                                                                                                          </span><br><span class="line">CMD echo "-------end------"                                                                                                                                                                               </span><br><span class="line">CMD /bin/bash                                                                                                                                                                                             </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 构建镜像</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z docker-file-test]# docker build -f dockerfile1 -t guoxb/centos .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看镜像列表</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z docker-file-test]# docker images                                                                                                                                            </span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE                                                                                                                                      </span><br><span class="line">guoxb/centos          latest    93370156ea8b   32 seconds ago   209MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行我们的容器</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z docker-file-test]# docker run -it 5c5d2169b8a0                     </span><br><span class="line">[root@3a8456c4fa25 /]# ls                                                                                                                                                                                 </span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01  volume02</span><br><span class="line"><span class="meta">#</span> volume01  volume02 这个目录就是我们生成镜像的时候自动挂载的（匿名挂载），数据卷目录</span><br><span class="line"><span class="meta">#</span> 这个卷和外部一定有一个同步的目录</span><br><span class="line"><span class="meta">#</span> docker inspect 82a5f09a71f7 查看容器信息</span><br></pre></td></tr></table></figure><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210130094748286.png" alt="image-20210130094748286"></p><p>假设构架镜像的时候没有挂载卷，要手动为镜像挂载：<code>-v 卷名:容器内路径</code></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><blockquote><p><strong>方式三：–volumes-from 挂载</strong></p></blockquote><p>多个 mysql 同步数据</p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210130095317573.png" alt="image-20210130095317573"></p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210130102538415.png" alt="image-20210130102538415"></p><p>docker01 即为数据卷容器</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>dockerfile 用来构建 docker 镜像的文件！</p><p>构建步骤：</p><ol><li>编写一个 dockerfile 文件</li><li>docker build 构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像（DockerHub、阿里云镜像仓库）</li></ol><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER# 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD# 步骤：tomcat 镜像，这个 tomcat 压缩包！添加内容</span><br><span class="line">WORKDIR# 镜像的工作目录</span><br><span class="line">VOLUME# 挂载的目录</span><br><span class="line">EXPOSE# 暴露端口-保留端口配置</span><br><span class="line">CMD# 指定这个容器启动的时候要运行的命令：只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT# 指定这个容器启动的时候要运行的命令：可以追加命令</span><br><span class="line">ONBUILD# 当构建一个被继承 Dockerfile 的时候就会运行 ONBUILD 指令。触发指令</span><br><span class="line">COPY# 类似 ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV# 构建的时候设置环境变量</span><br></pre></td></tr></table></figure><blockquote><p><strong>CMD 和 ENTRYPOINT 区别</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMD ["ls", "-a"]</span><br><span class="line"><span class="meta">#</span> docker run -l  =&gt;  Error（-l 替换了 ls -a，所以报错）</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["ls", "-a"]</span><br><span class="line"><span class="meta">#</span> docker run -l  =&gt;  ls -al（-l 追加在 ls -a 后面）</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>Docker Hub 中 99% 镜像都是从这个基础镜像过来的 <code>FROM scratch</code>，然后配置需要的软件和配置来进行的构建</p><blockquote><p><strong>创建一个自己的 centos</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 编写 Dockerfile 文件</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# cat dockerfile_my_centos</span><br><span class="line">FROM centos                                                                     </span><br><span class="line">MAINTAINER guoxb&lt;gxbxemail@163.com&gt;                                             </span><br><span class="line">                                                                                </span><br><span class="line">ENV MYPATH /usr/local                                                           </span><br><span class="line">WORKDIR $MYPATH                # 希望进入容器直接在该目录下                     </span><br><span class="line">                                                                                </span><br><span class="line">RUN yum -y install vim         # 添加 vim 指令                                  </span><br><span class="line">RUN yum -y install net-tools   # 添加 ifconfig 指令                             </span><br><span class="line">                                                                                </span><br><span class="line">EXPOSE 80                                                                       </span><br><span class="line">                                                                                </span><br><span class="line">CMD echo $MYPATH      </span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 通过这个文件构建镜像</span><br><span class="line">[root@guoxb dockerfiles]# docker build -f dockerfile_my_centos -t mycentos:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3. 测试运行</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker run -it mycentos:0.1</span><br><span class="line">[root@56faa376f9c3 local]# ls</span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  sbin  share  src</span><br><span class="line">[root@56faa376f9c3 local]# pwd</span><br><span class="line">/usr/local</span><br></pre></td></tr></table></figure><p>我们可以列出本地镜像的变更历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker history ff91b0d1fc9f                                                                                                      </span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT                                                                             </span><br><span class="line">ff91b0d1fc9f   7 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/bin…   0B        </span><br><span class="line">43a790ec69f1   7 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span><br><span class="line">6a308d482c0a   7 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B        </span><br><span class="line">16eba5136010   7 minutes ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        </span><br><span class="line">b404f46f94b6   7 minutes ago   /bin/sh -c yum -y install net-tools             23.3MB    </span><br><span class="line">e9cdf9c370e0   8 minutes ago   /bin/sh -c yum -y install vim                   58.1MB    </span><br><span class="line">ebd6879e0f3d   8 minutes ago   /bin/sh -c #(nop) WORKDIR /usr/local            0B        </span><br><span class="line">38e92dbca281   8 minutes ago   /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B        </span><br><span class="line">d7a86a6e55d6   8 minutes ago   /bin/sh -c #(nop)  MAINTAINER guoxb&lt;gxbxemai…   0B        </span><br><span class="line">300e315adb2f   7 weeks ago     /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B        </span><br><span class="line">&lt;missing&gt;      7 weeks ago     /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        </span><br><span class="line">&lt;missing&gt;      7 weeks ago     /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7…   209MB</span><br></pre></td></tr></table></figure><h3 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h3><blockquote><p><strong>DockerHub</strong></p></blockquote><ol><li><p>地址 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 注册自己的账号</p></li><li><p>在我们服务器上提交自己的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z /]# docker login --help                                                                                                                          </span><br><span class="line">                                                                                                                          </span><br><span class="line">Usage:  docker login [OPTIONS] [SERVER]                                                                                   </span><br><span class="line">                                                                                                                          </span><br><span class="line">Log in to a Docker registry.                                                                                              </span><br><span class="line">If no server is specified, the default is defined by the daemon.                                                          </span><br><span class="line">                                                                                                                          </span><br><span class="line">Options:                                                                                                                  </span><br><span class="line">  -p, --password string   Password                                                                                        </span><br><span class="line">      --password-stdin    Take the password from stdin                                                                    </span><br><span class="line">  -u, --username string   Username</span><br></pre></td></tr></table></figure></li><li><p>登录完毕后就可以提交镜像了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z /]# docker images                                                                                                                                </span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED        SIZE                                                                                                             </span><br><span class="line">mycentos              0.1       ff91b0d1fc9f   24 hours ago   291MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> push 镜像的问题？</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z /]# docker push guoxiaobo/mycentos:0.1                                                                                                           </span><br><span class="line">The push refers to repository [docker.io/guoxiaobo/mycentos]                                                                                                                   </span><br><span class="line">An image does not exist locally with the tag: guoxiaobo/mycentos # 失败</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解决，增加一个 tag</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z /]# docker tag mycentos:1.0 guoxiaobo/mycentos:1.0 </span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z /]# docker push guoxiaobo/mycentos:1.0                                                                                                           </span><br><span class="line">The push refers to repository [docker.io/guoxiaobo/mycentos]</span><br><span class="line">20ae4dd0cb18: Pushing [======================&gt;                            ]  10.37MB/23.33MB                                                                                   </span><br><span class="line">b6a9fd2ac02d: Pushing [========================&gt;                          ]  28.11MB/58.05MB                                                                                   </span><br><span class="line">2653d992f4ef: Pushing [======&gt;                                            ]  28.36MB/209.3MB</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>阿里云镜像</strong></p></blockquote><ol><li><p>进入控制台-容器镜像服务</p></li><li><p>创建命名空间</p></li><li><p>创建镜像仓库</p></li><li><p>浏览阿里云，提交镜像</p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210131141832405.png" alt="image-20210131141832405"></p></li></ol><blockquote><p><strong>小结</strong></p></blockquote><p><img src="/2021/01/22/Docker/Docker 核心技术/u=3762540439,4180220111&amp;fm=26&amp;gp=0.png" alt="img"></p><p><img src="/2021/01/22/Docker/Docker 核心技术/u=3762540439,4180220111&amp;fm=26&amp;gp=1.png" alt="img"></p><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210131143402237.png" alt="image-20210131143402237"></p><p>三个网络</p><p><code># 问题：docker 是如何处理容器网络访问的？</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker run -d -P --name tomcat01 tomcat </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看容器的内部网络地址 ip addr，发现容器启动的时候会得到一个 eth0@if127 IP地址，这是 docker 分配的！</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker exec -it tomcat01 ip addr                                                                                                   </span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000                                                                                    </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00                                                                                                                      </span><br><span class="line">    inet 127.0.0.1/8 scope host lo                                                                                                                                             </span><br><span class="line">       valid_lft forever preferred_lft forever                                                                                                                                 </span><br><span class="line">126: eth0@if127: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default                                                                               </span><br><span class="line">    link/ether 02:42:ac:11:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0                                                                                                          </span><br><span class="line">    inet 172.17.0.4/16 brd 172.17.255.255 scope global eth0                                                                                                                    </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta">#</span> 思考：Linux 能不能 ping 通容器内部？</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# ping 172.17.0.4                                                                                                                    </span><br><span class="line">PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.                                                                                                                             </span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.106 ms                                                                                                                      </span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.070 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Linux 可以 ping 通 docker 容器内部</span><br></pre></td></tr></table></figure><blockquote><p><strong>原理</strong></p></blockquote><ol><li>我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，我们只要安装了 docker，就会有一个网卡 docker0 桥接模式，使用的技术是 veth-pair 技术！</li></ol><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210131144946560.png" alt="image-20210131144946560"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 我们发现这个容器带来的网卡，都是一对一对的</span><br><span class="line"><span class="meta">#</span> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><br><span class="line"><span class="meta">#</span> 正因为有这个特性，veth-pair 充当一个桥梁</span><br></pre></td></tr></table></figure><ol start="2"><li>测试下 tomcat01 和 tomcat02 是否可以 ping 通？</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker exec -it tomcat02 ip addr</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker exec -it tomcat01 ip addr </span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z dockerfiles]# docker exec -it tomcat01 ping 172.17.0.5</span><br></pre></td></tr></table></figure><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210131151017293.png" alt="image-20210131151017293"></p><p>结论：tomcat01 和 tomcat02 是公用的一个路由器 - docker0。</p><p>所有的容器不指定网络的情况下，都是 docker0 路由的，docker 会给我们的容器分配一个默认可用的 ip</p><h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><blockquote><p><strong>思考：我们编写一个微服务，database url=ip：，项目重启，数据库ip变了，连不上了；我们希望可以处理这个问题，可以通过名字访问容器</strong></p></blockquote><p>例如：<code>docker exec -it tomcat01 ping tomcat02</code> 是不通的</p><p>解决：我们可以使用 <code>--link</code> 解决这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker run -it --name tomcat01 --link tomcat02 tomcat</span><br></pre></td></tr></table></figure><p>此时 tomcat01 是可以 ping 通 tomcat02 的，反过来能不能 ping 通呢？不能！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看容器 hosts 配置</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker ps</span><br><span class="line">CONTAINER ID   NAMES</span><br><span class="line">247b6904b38f   tomcat02</span><br><span class="line">e455cff7c7b8   tomcat01</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker exec -it tomcat01 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">172.17.0.2      e455cff7c7b8</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker exec -it tomcat02 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">172.17.0.2      tomcat01 e455cff7c7b8 </span><br><span class="line">172.17.0.3      247b6904b38f</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> --link 就是在 hosts 配置中增加了一个 tomcat01 的映射 172.17.0.2    tomcat01 e455cff7c7b8</span><br><span class="line"><span class="meta">#</span> 也就是我们 ping 镜像名称 或 镜像ID，会直接映射到 172.17.0.2，所以可以 ping 通</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><blockquote><p>查看所有docker网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE           </span><br><span class="line">2a10ae850766   bridge    bridge    local           </span><br><span class="line">64092a54de34   host      host      local           </span><br><span class="line">736a8a5d6989   none      null      local</span><br></pre></td></tr></table></figure><p>知识点：网络模式</p><ol><li>bridge：桥接（docker，创建网络也用bridge模式）</li><li>none：不配置网络</li><li>host：和宿主机共享网络</li><li>container：容器网络联通（用的少，局限大）</li></ol><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> --net bridge 是一个默认参数，而这个就是 docker0</span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker0 特点：（1）默认的；（2）域名不能访问；（3）--link 可以打通连接（比较麻烦）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 基于以上不足，我们自定义一个网络！</span><br><span class="line"><span class="meta">#</span> --driver bridge桥接</span><br><span class="line"><span class="meta">#</span> --subnet 192.168.0.0/16子网</span><br><span class="line"><span class="meta">#</span> --gateway 192.168.0.1网关</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">2a10ae850766   bridge    bridge    local</span><br><span class="line">64092a54de34   host      host      local</span><br><span class="line">1b599f8ce9b9   mynet     bridge    local</span><br><span class="line">736a8a5d6989   none      null      local</span><br></pre></td></tr></table></figure><p>到这里，我们自己的网络就创建好了！之后的服务我们就可以放在我们自己的网络里面。</p><p><img src="/2021/01/22/Docker/Docker 核心技术/image-20210201142102274.png" alt="image-20210201142102274"></p><p>启动两个容器在 mynet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看 mynet 详请</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker network inspect mynet</span><br><span class="line">[                                                                                                 </span><br><span class="line">    &#123;                                                                                             </span><br><span class="line">        "Name": "mynet",</span><br><span class="line">        "Id": "1b599f8ce9b99e16d53a428849466f770bdbd0a451acefa706c8c02e2918f736",                 </span><br><span class="line">        "Created": "2021-02-01T13:45:13.742621517+08:00",                                         </span><br><span class="line">        "Scope": "local",                                                                         </span><br><span class="line">        "Driver": "bridge",                                                                       </span><br><span class="line">        "EnableIPv6": false,</span><br><span class="line">        "IPAM": &#123;                                                                                 </span><br><span class="line">            "Driver": "default",</span><br><span class="line">            "Options": &#123;&#125;,</span><br><span class="line">            "Config": [                                                                           </span><br><span class="line">                &#123;                                                                                 </span><br><span class="line">                    "Subnet": "192.168.0.0/16",                                                   </span><br><span class="line">                    "Gateway": "192.168.0.1"</span><br><span class="line">                &#125;                                                                                 </span><br><span class="line">            ]                                                                                     </span><br><span class="line">        &#125;,     </span><br><span class="line">        "Internal": false, </span><br><span class="line">        "Attachable": false, </span><br><span class="line">        "Ingress": false,                                                                         </span><br><span class="line">        "ConfigFrom": &#123;                                                                           </span><br><span class="line">            "Network": ""                                                                         </span><br><span class="line">        &#125;,  </span><br><span class="line">        "ConfigOnly": false,   </span><br><span class="line">        "Containers": &#123;                                                                           </span><br><span class="line">            "720e5432f1d2d39c67a95f2d9cc07c5ab72e2b37834ccf6d3d268c787ce32adb": &#123;                 </span><br><span class="line">                "Name": "tomcat-net-01",      </span><br><span class="line">                "EndpointID": "24beee65adafe0775b73453a13c52a36be6c6d99fc117c219c7a0eaa1052a079", </span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:02",</span><br><span class="line">                "IPv4Address": "192.168.0.2/16",</span><br><span class="line">                "IPv6Address": ""                                                                 </span><br><span class="line">            &#125;,               </span><br><span class="line">            "d8ce9e2d80d08cb7094a68caad5d85c1aeaf990f1f1bfb372eff0617396a7fc9": &#123;                 </span><br><span class="line">                "Name": "tomcat-net-02", </span><br><span class="line">                "EndpointID": "5dfec94bdf30a9ff038c66053eaa030f3f76538a823120aa3ace32c0e6700017", </span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:03",</span><br><span class="line">                "IPv4Address": "192.168.0.3/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Labels": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> tomcat-net-01 与 tomcat-net-02 互 ping 是可以 ping 通的！</span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.075 ms</span><br><span class="line"></span><br><span class="line">[root@iZm5e7sydivirj1yfamuq8Z ~]# docker exec -it tomcat-net-02 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.047 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.066 ms</span><br></pre></td></tr></table></figure><p>使用自建网络的好处：不同集群使用不同的网络，保证集群是安全和健康的！</p><h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><blockquote><p><strong>官方介绍</strong></p></blockquote><p><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p><ol><li>帮助定义、运行多个容器的工具</li><li>需要定义一个 YAML file 配置文件</li><li>用一些 single command 命令</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>下载</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.28.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ol start="2"><li>授权</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="YAML-规则"><a href="#YAML-规则" class="headerlink" title="YAML 规则"></a>YAML 规则</h3><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 3层</span><br><span class="line"></span><br><span class="line">version: "3.8"  # 版本</span><br><span class="line">services:# 服务</span><br><span class="line">服务1：web</span><br><span class="line"><span class="meta">#</span> 服务配置</span><br><span class="line">images</span><br><span class="line">build</span><br><span class="line">network</span><br><span class="line">...</span><br><span class="line">服务2：redis</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span> 其他配置：网络/卷、全局规则</span><br><span class="line">volumes:</span><br><span class="line">networks:</span><br><span class="line">configs:</span><br></pre></td></tr></table></figure><h3 id="docker-compose-命令模板"><a href="#docker-compose-命令模板" class="headerlink" title="docker-compose 命令模板"></a>docker-compose 命令模板</h3><p>两个重要的概念：</p><ol><li>服务（service）：一个服务就是一个应用容器</li><li>项目（project）：由多个服务共同组成的一个具有相同业务逻辑单元</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span> <span class="comment"># compose 版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  tomcat01:</span> <span class="comment"># 服务名</span></span><br><span class="line">    <span class="comment"># container_name: tomcat01_name # 相当于 run 的 --name</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">tomcat</span> <span class="comment"># 指定镜像名称 相当于 run image</span></span><br><span class="line"><span class="attr">    ports:</span> <span class="comment"># 完成host与容器端口映射关系 相当于 run 的 -p</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3000:8080"</span></span><br><span class="line"><span class="attr">    volumes:</span> <span class="comment"># 数据卷所挂载路径设置 相当于 run 的 -v</span></span><br><span class="line">      <span class="comment">#- /home/docker-study:/usr/local/tomcat/webapps # 自定义路径映射</span></span><br><span class="line"><span class="attr">      - tomcatwebapps:</span><span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line"><span class="attr">    networks:</span> <span class="comment"># 相当于 run 的 --network</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker_study</span> <span class="comment"># 代表当前服务使用哪个网络桥</span></span><br><span class="line"><span class="attr">  tomcat02:</span> <span class="comment"># 服务名</span></span><br><span class="line">    <span class="comment"># container_name: tomcat02_name # 相当于 run 的 --name</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">tomcat</span> <span class="comment"># 指定镜像名称</span></span><br><span class="line"><span class="attr">    ports:</span> <span class="comment"># 完成host与容器端口映射关系</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3001:8080"</span></span><br><span class="line"><span class="attr">    volumes:</span> <span class="comment"># 数据卷所挂载路径设置</span></span><br><span class="line">      <span class="comment">#- /home/docker-study:/usr/local/tomcat/webapps # 自定义路径映射</span></span><br><span class="line"><span class="attr">      - tomcatwebapps:</span><span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker_study</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="comment"># 环境配置 相当于 run 的 -e</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ROOT_PASSWORK=root</span></span><br><span class="line">    <span class="comment"># env_file: # 用来将 environment 中的环境变量放入 mysql.env 文件中，避免私密信息暴露</span></span><br><span class="line">    <span class="comment">#   - ./mysql.env</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># build: # 启动服务时，先将 build 命令中指定的 Dockerfile 打包成镜像，再运行该镜像</span></span><br><span class="line">    <span class="comment">#   context: [Dockerfile路径]</span></span><br><span class="line">    <span class="comment">#   dockerfile: [Dockerfile名称]</span></span><br><span class="line">    <span class="comment"># container_name: web</span></span><br><span class="line"><span class="attr">    depends_on:</span> <span class="comment"># 代表这个容器必须依赖哪些容器启动之后才能启动</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">tomcat01</span> <span class="comment"># 这里写的是 *服务名*</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  tomcatwebapps:</span> <span class="comment"># 定义使用的卷名</span></span><br><span class="line"><span class="attr">    external:</span> <span class="comment"># 使用自定义卷名</span></span><br><span class="line">      <span class="literal">false</span>   <span class="comment"># ture 确定使用自定义卷名(前提：需在服务器将此卷名创建出来)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 定义服务用到的桥 默认创建的是 bridge</span></span><br><span class="line"><span class="attr">  docker_study:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="comment"># 使用自定义网络名称</span></span><br><span class="line">      <span class="literal">false</span>   <span class="comment"># ture 确定使用自定义网络名(前提：需在服务器将此网络创建出来)</span></span><br></pre></td></tr></table></figure><h3 id="docker-compose-指令"><a href="#docker-compose-指令" class="headerlink" title="docker-compose 指令"></a>docker-compose 指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker-compose 命令选项</span><br><span class="line">-f: 指定使用的 Compose 模板文件，默认为 docker-compose.yml</span><br><span class="line">-p: 指定项目名称，默认使用所在目录名称作为项目名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker-compose up</span><br><span class="line">默认情况下，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volume-from 挂载的卷），以保证启动的服务匹配 docker-compose.yml 文件的最新内容</span><br><span class="line">-d: 将会在后台启动并运行所有容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker-compose down</span><br><span class="line">将会停止 up 命令所启动的容器，并移除网络</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker-compose exec mysql(docker-compose.yml中声明的服务id) bash</span><br><span class="line">进入容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker-compose top</span><br><span class="line">查看各个服务容器内运行的进程</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker-compose logs [服务id]</span><br><span class="line">查看服务日志</span><br></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx                     构建建启动nignx容器</span><br><span class="line">docker-compose exec nginx bash            登录到nginx容器中</span><br><span class="line">docker-compose down                             删除所有nginx容器,镜像</span><br><span class="line">docker-compose ps                                 显示所有容器</span><br><span class="line">docker-compose restart nginx                   重新启动nginx容器</span><br><span class="line">docker-compose run --no-deps --rm php-fpm php -v  在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</span><br><span class="line">docker-compose build nginx                     构建镜像 。        </span><br><span class="line">docker-compose build --no-cache nginx   不带缓存的构建。</span><br><span class="line">docker-compose logs  nginx                     查看nginx的日志 </span><br><span class="line">docker-compose logs -f nginx                   查看nginx的实时日志</span><br><span class="line">docker-compose config  -q                        验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。 </span><br><span class="line">docker-compose events --json nginx       以json的形式输出nginx的docker日志</span><br><span class="line">docker-compose pause nginx                 暂停nignx容器</span><br><span class="line">docker-compose unpause nginx             恢复ningx容器</span><br><span class="line">docker-compose rm nginx                       删除容器（删除前必须关闭容器）</span><br><span class="line">docker-compose stop nginx                    停止nignx容器</span><br><span class="line">docker-compose start nginx                    启动nignx容器</span><br></pre></td></tr></table></figure><h2 id="镜像安装"><a href="#镜像安装" class="headerlink" title="镜像安装"></a>镜像安装</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/nginx/www /home/nginx/logs /home/nginx/conf</span><br><span class="line"></span><br><span class="line">-v /home/nginx/www:/usr/share/nginx/html -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/logs:/var/log/nginx /home/data/www/gitroot/gxbxblog:/home/data/www/gitroot/gxbxblog nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS - Runtime 总结</title>
      <link href="/2019/12/12/iOS/iOS%20Runtime%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/12/iOS/iOS%20Runtime%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OC是一门动态语言，它会把一些编译时做的决定推迟到运行时。因此，仅仅有编译器是不够的，还需要一个运行时系统（Runtime System）来执行编译后的代码。</p><p>Runtime系统的核心是一个用C，C++以及在最核心的消息发送部分甚至使用汇编语言编写的一套底层API库，它是OC面向对象和动态发送消息的基石。</p><p>简单来说， Runtime 是一个库，这个库使我们可以在程序运行时创建对象、检查对象，修改类和对象的方法。<br><a id="more"></a></p><p>首先附上源码下载地址：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime开源代码</a></p><h2 id="一-Runtime是什么？"><a href="#一-Runtime是什么？" class="headerlink" title="一. Runtime是什么？"></a>一. Runtime是什么？</h2><p>OC是一门动态语言，它会把一些编译时做的决定推迟到运行时。因此，仅仅有编译器是不够的，还需要一个运行时系统（Runtime System）来执行编译后的代码。</p><p>Runtime系统的核心是一个用C，C++以及在最核心的消息发送部分甚至使用汇编语言编写的一套底层API库，它是OC面向对象和动态发送消息的基石。</p><p>简单来说， Runtime 是一个库，这个库使我们可以在程序运行时创建对象、检查对象，修改类和对象的方法。</p><h2 id="二-Runtime是做什么的？有什么用？"><a href="#二-Runtime是做什么的？有什么用？" class="headerlink" title="二. Runtime是做什么的？有什么用？"></a>二. Runtime是做什么的？有什么用？</h2><p>首先，通过Runtime库可以：</p><ol><li>获取类里面的所有成员变量；</li><li>为类动态添加成员变量；</li><li>动态改变类的方法实现；</li><li>为类动态添加新的方法；</li></ol><p><strong>重点</strong>：Runtime属于OC的底层，我们可以使用Runtime进行一些非常底层的操作，而这些操作是OC无法做到的，或者是OC不容易实现的。</p><h2 id="三-Runtime是怎么工作的？"><a href="#三-Runtime是怎么工作的？" class="headerlink" title="三. Runtime是怎么工作的？"></a>三. Runtime是怎么工作的？</h2><p>先来了解几个概念</p><h4 id="1-Class-和-Object"><a href="#1-Class-和-Object" class="headerlink" title="1. Class 和 Object"></a>1. Class 和 Object</h4><p>objc.h 中，Class 被定义为指向 objc_class 的指针，定义如下：<br><code>typedef struct objc_class *Class;</code></p><p>objc_class  是一个结构体，在 runtime.h 中定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;                                // 实现方法调用的关键</span><br><span class="line">    Class super_class;                        // 父类</span><br><span class="line">    const char * name;                        // 类名</span><br><span class="line">    long version;                             // 类的版本信息，默认为0</span><br><span class="line">    long info;                                // 类信息，供运行期使用的一些位标识</span><br><span class="line">    long instance_size;                       // 该类的实例变量大小</span><br><span class="line">    struct objc_ivar_list * ivars;            // 该类的成员变量链表</span><br><span class="line">    struct objc_method_list ** methodLists;   // 方法定义的链表</span><br><span class="line">    struct objc_cache * cache;                // 方法缓存</span><br><span class="line">    struct objc_protocol_list * protocols;    // 协议链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>提示：在 Xcode 中，使用快捷键 cmd + shift + o，在搜索框中输入 objc_class 即可查看定义</p></blockquote><p>通过查看这些定义，我们可以知道：一个类保存了自身所有的成员变量，所有的方法，所有的实现的协议。</p><p>还有两个比较重要的字段 isa 和 cache，isa 指向对应类的元类，下面在元类篇幅会讲到，在探索 cache 之前，先看下 OC 中对象的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>objc_object 中只包含一个 isa 指针，而 id 是一个指向 objc_object 的指针。</p><p>也就是说，一个对象唯一保存的信息就是它的 Class 地址，当调用一个对象的方法时，会通过 isa 找到对应的 objc_class，然后再在 objc_class 的方法列表中找到对应的方法执行。</p><p>再说 cache，因为调用方法实际上是从方法列表 methodLists 中查找的过程，如果每次都去 methodLists 中查找，效率会很低。所以对调用过的方法，会以 map 的方式缓存在 cache 中，下次调用会快很多。</p><h4 id="2-Meta-Class-元类"><a href="#2-Meta-Class-元类" class="headerlink" title="2. Meta Class 元类"></a>2. Meta Class 元类</h4><p>观察 objc_class 和 objc_object 的定义，不难发现两者本质相同，只是包含的字段不同，在 OC 中，<strong>类也被设计为一个对象，类的类型就是元类（Meta Class）</strong>。</p><p><strong>OC中每个类都有对应的元类</strong>，元类的 methodLists 中保存了类的方法链表，即所谓的 <strong>类方法</strong>。类的 isa 指针指向对应的元类（上面的问题，在此处有了答案）。</p><p>所以，调用一个对象的类方法的过程如下：</p><ol><li>通过对象的 isa 指针找到对应的类；</li><li>通过类的 isa 指针找到对应的元类；</li><li>在元类 methodLists 中找到对应方法，然后执行。</li></ol><p>元类也有一个 isa 指针，元类也是一个对象。</p><p>元类的 isa 指向基类的元类，基类的元类的 isa 指向自己。</p><p><img src="/2019/12/12/iOS/iOS Runtime总结/20191212171727713.jpg"></p><h4 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h4><p>上面讲到，「找到对应的方法，然后执行」，那么这个「执行」是怎样进行的呢？下面就来介绍一下 OC 中的方法调用。</p><p>Method 在 runtime.h 中的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char * method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 Method 被定义为一个 objc_method 指针，在 objc_method 结构体中，包含一个 SEL 和 一个IMP，同样看下它们的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SEL</span><br><span class="line">typedef struct objc_selector *SEL;</span><br><span class="line"></span><br><span class="line">// IMP</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ );</span><br></pre></td></tr></table></figure><h5 id="（1）SEL-是指向-objc-selector-的指针，而-objc-selector-在头文件找不到定义，测试下："><a href="#（1）SEL-是指向-objc-selector-的指针，而-objc-selector-在头文件找不到定义，测试下：" class="headerlink" title="（1）SEL 是指向 objc_selector 的指针，而 objc_selector 在头文件找不到定义，测试下："></a>（1）SEL 是指向 objc_selector 的指针，而 objc_selector 在头文件找不到定义，测试下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL sel = @selector(helloworld);</span><br><span class="line">NSLog(@&quot;%s&quot;, sel);          // 输出：helloworld</span><br><span class="line">SEL sel1 = @selector(viewDidLoad1);</span><br><span class="line">NSLog(@&quot;%s&quot;, sel1);         // 输出：viewDidLoad1</span><br></pre></td></tr></table></figure><p>因此，我们可以认为：<strong>SEL是一个保存方法名的字符串</strong>。</p><h5 id="（2）IMP-是一个「函数指针」，就是用来找到函数地址，然后执行函数的"><a href="#（2）IMP-是一个「函数指针」，就是用来找到函数地址，然后执行函数的" class="headerlink" title="（2）IMP 是一个「函数指针」，就是用来找到函数地址，然后执行函数的"></a>（2）IMP 是一个「函数指针」，就是用来找到函数地址，然后执行函数的</h5><p><strong>注意</strong>：IMP 指向的函数的前两个参数是默认参数，id 和 SEL。id 对于实例方法来说，self 保存了当前对象地址；对与类方法来说，self 保存了当前对应类对象的地址。后面的省略号是参数列表。</p><p>综上：Method 建立了 SEL 和 IMP 的关联，当对一个对象发送消息时，会通过 SEL 找到 IMP，然后执行。</p><h5 id="（3）在-OC-中，所有的方法调用，都会转化为向对象发送消息。发送消息使用-objc-msgSend-函数"><a href="#（3）在-OC-中，所有的方法调用，都会转化为向对象发送消息。发送消息使用-objc-msgSend-函数" class="headerlink" title="（3）在 OC 中，所有的方法调用，都会转化为向对象发送消息。发送消息使用 objc_msgSend 函数"></a>（3）在 OC 中，所有的方法调用，都会转化为向对象发送消息。发送消息使用 objc_msgSend 函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// objc_msgSend</span><br><span class="line">objc_msgSend(void /* id self, SEL op, ... */ )</span><br><span class="line"></span><br><span class="line">// 上面提到的 IMP</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ );</span><br></pre></td></tr></table></figure><p>可以发现，参数列表和 IMP 指向的函数参数列表是相对应的。</p><p>以下两段代码是相等的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OC 实现</span><br><span class="line">[self doSomething];</span><br><span class="line"></span><br><span class="line">// runtime 实现</span><br><span class="line">objc_msgSend(self, @selector(doSomethiing));</span><br></pre></td></tr></table></figure><h5 id="（4）objc-msgSend-会默认传入-id-和-SEL，这对应了两个隐含参数，self-和-cmd。意味着，我们可以在方法实现过程中拿到它们，并使用它们。看代码："><a href="#（4）objc-msgSend-会默认传入-id-和-SEL，这对应了两个隐含参数，self-和-cmd。意味着，我们可以在方法实现过程中拿到它们，并使用它们。看代码：" class="headerlink" title="（4）objc_msgSend 会默认传入 id 和 SEL，这对应了两个隐含参数，self 和 _cmd。意味着，我们可以在方法实现过程中拿到它们，并使用它们。看代码："></a>（4）objc_msgSend 会默认传入 id 和 SEL，这对应了两个隐含参数，self 和 _cmd。意味着，我们可以在方法实现过程中拿到它们，并使用它们。看代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)testCmd:(NSNumber *)num &#123;</span><br><span class="line">    NSLog(@&quot;%ld&quot;, (long)num.integerValue);</span><br><span class="line">    num = [NSNumber numberWithInteger:num.integerValue-1];</span><br><span class="line">    if (num.integerValue &gt; 0) &#123;</span><br><span class="line">        [self performSelector:_cmd withObject:num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试调用：</p><p><code>[self testCmd:@(5)];</code></p><p>输出：5，4，3，2，1</p><p>即我们可以在方法内部用 _cmd 调用方法自身。</p><h5 id="（5）下面讨论类之间继承的情况，objc-class-结构体中，包含一个指向父类的指针-super-class"><a href="#（5）下面讨论类之间继承的情况，objc-class-结构体中，包含一个指向父类的指针-super-class" class="headerlink" title="（5）下面讨论类之间继承的情况，objc_class 结构体中，包含一个指向父类的指针 super_class"></a>（5）下面讨论类之间继承的情况，objc_class 结构体中，包含一个指向父类的指针 super_class</h5><p>即当向一个对象发送消息时，会去这个类的 methodLists 中查找相应的 SEL ，如果查不到，则通过 super_class 指针找到父类，再去父类的 methodLists 中查找，层层递进。最后仍然找不到，才走抛异常流程。</p><p><img src="/2019/12/12/iOS/iOS Runtime总结/2019121218280385.jpg"></p><h5 id="（6）当一个方法找不到的时候，会走拦截调用和消息转发流程"><a href="#（6）当一个方法找不到的时候，会走拦截调用和消息转发流程" class="headerlink" title="（6）当一个方法找不到的时候，会走拦截调用和消息转发流程"></a>（6）当一个方法找不到的时候，会走拦截调用和消息转发流程</h5><p>我们可以重写 +resolveClassMethod: 和 +resolveInstanceMethod: 方法，在程序崩溃前做一些处理。通常的做法是动态添加一个方法，并返回 YES 告诉程序已经成功处理消息。如果这两个方法返回 NO ，这个流程会继续往下走，完整的流程如下图所示：</p><p><img src="/2019/12/12/iOS/iOS Runtime总结/20191212182957183.jpg"></p><h2 id="四-用-Runtime-实现具体功能"><a href="#四-用-Runtime-实现具体功能" class="headerlink" title="四. 用 Runtime 实现具体功能"></a>四. 用 Runtime 实现具体功能</h2><p>上面介绍了 Runtime 的原理，以及一些基本概念，下面上代码体验一下 Runtime 的魅力。</p><p>项目中使用 Runtime ，请首先引入这两个头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br></pre></td></tr></table></figure><h3 id="1-消息转发"><a href="#1-消息转发" class="headerlink" title="1. 消息转发"></a>1. 消息转发</h3><p>在 VC 中调用 <code>Person</code> 类的 <code>sendMessage</code> 方法，使用 OC 我们是这样调用的：<br><code>[[Person new] sendMessage:@&quot;hello&quot;];</code></p><p>用 Runtime 可以这样写：<br><code>objc_msgSend([Person new], @selector(sendMessage:), @&quot;world&quot;);</code></p><p>这里不再过多解释，上面有提到~</p><p>这里引入另一个问题，如果 <code>Person</code> 中没有 <code>sendMessage</code> 方法，程序肯定会崩溃，如果防止崩溃呢？那就用到了 Runtime 消息转发流程。</p><p>上面有 消息转发流程图 ，我们分三步走，这里我们直接上代码：</p><p>（1）<code>Person.m</code> 重写 <code>+ (BOOL)resolveInstanceMethod</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void sendMsg(id self, SEL _cmd, NSString *msg) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. resolveInstanceMethod 动态方法解析</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;sendMessage:&quot;]) &#123;</span><br><span class="line">        return class_addMethod(self, sel, (IMP)sendMsg, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Objective-C中的方法默认被隐藏了两个参数：self和_cmd。self指向对象本身，_cmd指向方法本身。</p><p>举两个例子来说明：</p><p>例一：<code>- (NSString *)name</code></p><p>这个方法实际上有两个参数：<code>self</code> 和 <code>_cmd</code>。</p><p>例二：<code>- (void)setValue:(int)val</code></p><p>这个方法实际上有三个参数：<code>self</code>, <code>_cmd</code> 和 <code>val</code>。</p><p>这里 <code>v@:@</code> 是什么东西呢？实际上，这里的第一个字符 <code>v</code> 代表函数的返回类型是 <code>void</code>，后面三个字符分别是    <code>self</code>, <code>_cmd</code>, <code>msg</code>，这三个参数的类型 <code>id</code>, <code>SEL</code>, <code>NSString</code>。</p><p>（2）如果上述方法返回 <code>NO</code>，接着走快速转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2. forwardingTargetForSelector 快速转发</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;sendMessage:&quot;]) &#123;</span><br><span class="line">        return [SpareWheel new]; // sendMessage 函数交由 SpareWheel 类处理</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果上述方法依然不能处理，将进入第三部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 3. forwardInvocation 慢速转发</span><br><span class="line">// （1）方法签名</span><br><span class="line">// （2）消息转发</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;sendMessage:&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    SpareWheel *tempObj = [SpareWheel new];</span><br><span class="line">    if ([tempObj respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:tempObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>methodSignatureForSelector:</code> 的作用在于为另一个类实现的消息创建一个有效的方法签名，必须实现，并且返回不为空的 <code>methodSignature</code>，否则会crash。</p><p><code>forwardInvocation:</code> 将选择器转发给一个真正实现了该消息的对象。</p><p>如果走完 慢速转发 还实现不了，那就走 <code>doesNotRecognizeSelector:</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;找不到方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Method-Swizzling-方法交换"><a href="#2-Method-Swizzling-方法交换" class="headerlink" title="2. Method Swizzling 方法交换"></a>2. Method Swizzling 方法交换</h3><p>Method Swizzling 使我们有办法在程序运行的时候，去修改一个方法的实现，以下是简单实现 lg_reloadData 替换 UITableView 的 reloadData 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method originMethod = class_getInstanceMethod(self, @selector(reloadData));</span><br><span class="line">    Method currentMethod = class_getInstanceMethod(self, @selector(lg_reloadData));</span><br><span class="line">    if (!class_addMethod([self class], @selector(reloadData), method_getImplementation(currentMethod), method_getTypeEncoding(currentMethod))) &#123;</span><br><span class="line">        method_exchangeImplementations(originMethod, currentMethod);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        class_replaceMethod([self class], @selector(lg_reloadData), method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p><code>reloadData：</code>被替换方法</p><p><code>lg_reloadData：</code>替换方法</p><p><code>class_addMethod:</code>如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现</p><p>如果返回成功：则说明被替换方法没有存在。也就是被替换的方法没有被实现，我们需要先把这个方法实现，然后再执行我们想要的效果，用我们自定义的方法去替换被替换的方法。</p><p>如果返回失败：则说明被替换方法已经存在，直接将两个方法的实现交换即。</p><p><strong>为什么不直接用 method_exchangeImplementations 来交换就好？</strong></p><p>因为可能会影响父类中的方法。比如我们在一个子类中，去交换一个父类中的方法，而这个方法在子类中没有实现，这个时候父类的方法就指向了子类的实现，当这个方法被调用的时候就会出问题。所以先采取添加方法的方式，如果添加失败，证明子类已经实现了这个方法，直接用 method_exchangeImplementations 来交换；如果添加成功，则说明没有实现这个方法，采取先添加后替换的方式。这样就能保证不影响父类了。</p><p>请到 <a href="https://github.com/guoxiaobo-aj/RuntimeDemo" target="_blank" rel="noopener">GitHub</a> 上查看完整例子。</p><p>本文参考：<a href="http://www.cocoachina.com/articles/25821" target="_blank" rel="noopener">新手也看得懂的 iOS Runtime 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS - AJScrollContentView</title>
      <link href="/2019/12/11/iOS/AJScrollContentView/"/>
      <url>/2019/12/11/iOS/AJScrollContentView/</url>
      
        <content type="html"><![CDATA[<p>仿网易新闻，点击顶部标题，改变下面内容页面；以及，滑动内容页面，改变顶部标题的功能。<br>因为项目中多次用到这样的控件，很多主流App也有这样的需求，有必要简单封装一下，分享给更多的开发者。<br><a id="more"></a></p><p>仿网易新闻，点击顶部标题，改变下面内容页面；以及，滑动内容页面，改变顶部标题的功能。</p><p>因为项目中多次用到这样的控件，很多主流App也有这样的需求，有必要简单封装一下，分享给更多的开发者。</p><p>功能点：</p><ul><li>单个页面展示多个视图，并根据不同类型展示不同内容页面；</li><li>顶部视图类型通过点击切换下方内容视图页面；</li><li>分为顶部标题 和 下方内容展示页面，互相分离，高内聚，低耦合；</li><li>Controller只需要遵循相应的代理协议即可。</li></ul><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/2019/12/11/iOS/AJScrollContentView/aj_scroll_contentview.gif" width="300"></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>iOS 8以上</li><li>Xcode 8+</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>AJScrollContentView可通过Cocoapods获得，只需要将以下代码添加到Podfile文件：</p><p><code>&#39;AJScrollContentView&#39;,&#39;〜&gt; 0.0.1&#39;</code></p><p>或者cd到项目根目录，执行：</p><p><code>pod AJScrollContentView</code></p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="1-顶部-AJSegmentTitleView"><a href="#1-顶部-AJSegmentTitleView" class="headerlink" title="1. 顶部 AJSegmentTitleView"></a>1. 顶部 AJSegmentTitleView</h3><p>初始化方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 实例化对象-初始化方法</span><br><span class="line">/// @param frame frame</span><br><span class="line">/// @param titles 标题数组</span><br><span class="line">/// @param delegate 代理</span><br><span class="line">/// @param type 样式类型</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame titles:(NSArray *)titles delegate:(id&lt;AJSegmentTitleViewDelegate&gt;)delegate type:(AJSegmentTitleViewType)type;</span><br></pre></td></tr></table></figure><p>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">    AJSegmentTitleViewTypeDefault, // 默认</span><br><span class="line">    AJSegmentTitleViewTypeUnderLine // 带有下划线</span><br><span class="line">&#125; AJSegmentTitleViewType;</span><br><span class="line"></span><br><span class="line">/// 代理</span><br><span class="line">@property (nonatomic, weak) id&lt;AJSegmentTitleViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">/// 标题数组</span><br><span class="line">@property (nonatomic, strong) NSArray *titlesArray;</span><br><span class="line">/// 按钮-未选中-颜色</span><br><span class="line">@property (nonatomic, strong) UIColor *titleNormalColor;</span><br><span class="line">/// 按钮-选中-颜色</span><br><span class="line">@property (nonatomic, strong) UIColor *titleSelectColor;</span><br><span class="line">/// 按钮-未选中-文字样式</span><br><span class="line">@property (nonatomic, strong) UIFont *titleFont;</span><br><span class="line">/// 按钮-选中-文字样式</span><br><span class="line">@property (nonatomic, strong) UIFont *titleSelectFont;</span><br><span class="line">/// 当前-选中-的按钮下标</span><br><span class="line">@property (nonatomic, assign) NSInteger selectedIndex;</span><br><span class="line">/// 按钮左右内边距</span><br><span class="line">@property (nonatomic, assign) CGFloat btnPadding;</span><br><span class="line">/// 按钮中间边距</span><br><span class="line">@property (nonatomic, assign) CGFloat btnMargin;</span><br><span class="line">/// 类型</span><br><span class="line">@property (nonatomic, assign) AJSegmentTitleViewType type;</span><br></pre></td></tr></table></figure><p>代理协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol AJSegmentTitleViewDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">// 定位当前选中的标题按钮索引</span><br><span class="line">- (void)ajTitleViewClickedIndex:(NSInteger)currentIndex;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2-底部内容页-AJPageContentView"><a href="#2-底部内容页-AJPageContentView" class="headerlink" title="2. 底部内容页 AJPageContentView"></a>2. 底部内容页 AJPageContentView</h3><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 初始化</span><br><span class="line">/// @param frame frame</span><br><span class="line">/// @param childVCs 子控制器数组</span><br><span class="line">/// @param parentVC 父类vc</span><br><span class="line">/// @param delegate 代理对象</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame childVCs:(NSArray *)childVCs parentVC:(UIViewController *)parentVC delegate:(id&lt;AJPageContentViewDelegate&gt;)delegate;</span><br></pre></td></tr></table></figure><p>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;AJPageContentViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">/// 当前显示的view索引</span><br><span class="line">@property (nonatomic, assign) NSInteger contentViewCurrentIndex;</span><br><span class="line">/// 页面是否可手动滑动 - 默认可滑动</span><br><span class="line">@property (nonatomic, assign) BOOL canScroll;</span><br></pre></td></tr></table></figure><p>代理协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol AJPageContentViewDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">// 定位当前滚动到的内容页索引</span><br><span class="line">- (void)ajContentViewScrollEndDecelerating:(NSInteger)currentIndex;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>在使用到的VC中，直接引入头文件</p><p><code>#import &quot;AJScrollContentView.h&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">NSArray *pageTitles = @[@&quot;关注&quot;, @&quot;推荐&quot;, @&quot;热点&quot;, @&quot;北京&quot;, @&quot;新时代&quot;, @&quot;视频&quot;, @&quot;图片&quot;, @&quot;问答&quot;, @&quot;懂车帝&quot;, @&quot;军事&quot;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * title view</span><br><span class="line"> */</span><br><span class="line">self.titleView = [[AJSegmentTitleView alloc] initWithFrame:CGRectMake(0, STATUSBARHEIGHT + 44, SCREEN_WIDTH, 50) titles:_pageTitles delegate:self type:(AJSegmentTitleViewTypeUnderLine)];</span><br><span class="line">self.titleView.backgroundColor = UIColor.lightGrayColor;</span><br><span class="line">[self.view addSubview:self.titleView];</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line"> * content view</span><br><span class="line"> */</span><br><span class="line">NSMutableArray *childVCs = [NSMutableArray array];</span><br><span class="line">for (NSString *title in _pageTitles) &#123;</span><br><span class="line">    UIViewController *vc = [UIViewController new];</span><br><span class="line">    vc.view.backgroundColor = [self randomColor];</span><br><span class="line">    [childVCs addObject:vc];</span><br><span class="line">&#125;</span><br><span class="line">self.contentView = [[AJPageContentView alloc] initWithFrame:CGRectMake(0, STATUSBARHEIGHT + 44 + 50, SCREEN_WIDTH, SCREEN_HEIGHT - STATUSBARHEIGHT - 50 - 44) childVCs:childVCs parentVC:self delegate:self];</span><br><span class="line">[self.view addSubview:self.contentView];</span><br><span class="line">    </span><br><span class="line">self.titleView.selectedIndex = self.contentView.contentViewCurrentIndex = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - AJSegmentTitleViewDelegate</span><br><span class="line"></span><br><span class="line">- (void)ajTitleViewClickedIndex:(NSInteger)currentIndex &#123;</span><br><span class="line">    NSLog(@&quot;title - %ld&quot;, currentIndex);</span><br><span class="line">    self.contentView.contentViewCurrentIndex = currentIndex;</span><br><span class="line">    self.title = _pageTitles[currentIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - AJPageContentViewDelegate</span><br><span class="line"></span><br><span class="line">- (void)ajContentViewScrollEndDecelerating:(NSInteger)currentIndex &#123;</span><br><span class="line">    NSLog(@&quot;content - %ld&quot;, currentIndex);</span><br><span class="line">    self.titleView.selectedIndex = currentIndex;</span><br><span class="line">    self.title = _pageTitles[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码传送门：<a href="https://github.com/guoxiaobo-aj/AJScrollContentView" target="_blank" rel="noopener">https://github.com/guoxiaobo-aj/AJScrollContentView</a></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><ul><li>微博：<a href="https://weibo.com/p/1005055104640336" target="_blank" rel="noopener">@夜雨寒I</a></li><li>Email：<a href="mailto:gxbxemail@163.com" target="_blank" rel="noopener">gxbxemail@163.com</a></li><li>个人博客：<a href="https://guoxb.com">https://guoxb.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cocoapods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS序列化与反序列化</title>
      <link href="/2019/09/04/iOS/iOS%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2019/09/04/iOS/iOS%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在iOS中一个自定义对象是无法直接存入到文件中的，必须先转化成二进制流才行。<br>从对象到二进制数据的过程我们一般称为对象的序列化(Serialization)，也称为归档(Archive)。<br>同理，从二进制数据到对象的过程一般称为反序列化或者反归档。</p><a id="more"></a><h3 id="NSCoder"><a href="#NSCoder" class="headerlink" title="NSCoder"></a>NSCoder</h3><ul><li>归档（序列化） &amp; 解归档（反序列化）</li><li>提供简单函数，在 Object 和 二进制数据间进行转换</li><li>抽象类 具体功能需要子类实现</li></ul><h4 id="1-对象实现-NSSecureCoding-协议"><a href="#1-对象实现-NSSecureCoding-协议" class="headerlink" title="1. 对象实现 NSSecureCoding 协议"></a>1. 对象实现 NSSecureCoding 协议</h4><p>要实现对象的序列化，首先对象应该遵循 NSCoding 协议。因为 NSCoding 安全性不高，所以iOS6的时候，苹果引入了 NSSecureCoding 协议，加强安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ArticleModel.h</span><br><span class="line"></span><br><span class="line">@interface ArticleModel : NSObject&lt;NSSecureCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *artImg;</span><br><span class="line">@property (nonatomic, copy) NSString *artTitle;</span><br><span class="line">@property (nonatomic, copy) NSString *artPublishDate;</span><br><span class="line">@property (nonatomic, copy) NSString *artRefer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// ArticleModel.m</span><br><span class="line"></span><br><span class="line">@implementation ArticleModel</span><br><span class="line"></span><br><span class="line">// 解码方法</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.artImg = [aDecoder decodeObjectForKey:@&quot;art_img&quot;];</span><br><span class="line">        self.artTitle = [aDecoder decodeObjectForKey:@&quot;art_title&quot;];</span><br><span class="line">        self.artPublishDate = [aDecoder decodeObjectForKey:@&quot;friendly_date&quot;];</span><br><span class="line">        self.artRefer = [aDecoder decodeObjectForKey:@&quot;art_refer&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编码方法</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:self.artImg forKey:@&quot;art_img&quot;];</span><br><span class="line">    [aCoder encodeObject:self.artTitle forKey:@&quot;art_title&quot;];</span><br><span class="line">    [aCoder encodeObject:self.artPublishDate forKey:@&quot;friendly_date&quot;];</span><br><span class="line">    [aCoder encodeObject:self.artRefer forKey:@&quot;art_refer&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支持加密编码</span><br><span class="line">+ (BOOL)supportsSecureCoding &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-序列化存储-amp-反序列化读取"><a href="#2-序列化存储-amp-反序列化读取" class="headerlink" title="2. 序列化存储 &amp; 反序列化读取"></a>2. 序列化存储 &amp; 反序列化读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSString *cacheDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];    </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">NSString *fileDir = [cacheDir stringByAppendingPathComponent:@&quot;GTData&quot;];</span><br><span class="line">[fileManager createDirectoryAtPath:fileDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">NSString *filePath = [fileDir stringByAppendingPathComponent:@&quot;art_list&quot;];</span><br><span class="line"></span><br><span class="line">// 序列化存储</span><br><span class="line">NSData *artListData = [NSKeyedArchiver archivedDataWithRootObject:array requiringSecureCoding:YES error:nil];</span><br><span class="line"></span><br><span class="line">[fileManager createFileAtPath:filePath contents:artListData attributes:nil];</span><br><span class="line"></span><br><span class="line">// 反序列化读取</span><br><span class="line">NSData *readListData = [fileManager contentsAtPath:filePath];</span><br><span class="line">id unarchiveObj = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSArray class], [ArticleModel class], nil] fromData:readListData error:nil];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS文件管理</title>
      <link href="/2019/09/04/iOS/iOS%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2019/09/04/iOS/iOS%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>iOS 当中，每个 App程序 都有一个独立的文件管理系统，而且只能操作对应的文件系统当中的数据，这个文件系统被称为 <strong>沙盒</strong>。</p><a id="more"></a><h3 id="1-沙盒"><a href="#1-沙盒" class="headerlink" title="1. 沙盒"></a>1. 沙盒</h3><p><img src="/2019/09/04/iOS/iOS文件管理/ico_shahe.png" width="500px" alt="iOS文件系统"></p><p>沙盒分为两部分，一部分存放在独立的文件夹 Bundles 中，用于存放应用的二进制文件和应用的资源文件，以及 plist 应用配置信息等；还有一部分是苹果为我们分配好的Datas文件夹下的一些子文件目录，我们应用当中产生的数据，缓存信息等可以存放在这些目录下。</p><p><img src="/2019/09/04/iOS/iOS文件管理/ico_datas.png" width="300px" alt="Datas目录"></p><ul><li><code>Documents/</code> 可以进行备份和恢复，体积较大，一般存档用户数据（总结为：用户生产以及共享的文件）</li><li><code>Library/</code> 开发者最常用的文件夹，可以自定义子文件夹，可用来放置希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份<ul><li><code>Caches</code> 保存应用程序支持文件和缓存文件</li><li><code>Preferences</code> 保存应用程序偏好设置文件。<code>NSUserDefaults</code> 类创建的数据和 <code>plist</code> 文件都放在这里</li></ul></li><li><code>SystemData/</code> 顾名思义，就是系统提供的一些数据</li><li><code>tmp/</code> 临时数据，不会备份，启动是有可能被清空</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取沙盒根目录路径</span><br><span class="line">NSString *homeDir = NSHomeDirectory();</span><br><span class="line"></span><br><span class="line">// 获取Documents目录路径</span><br><span class="line">NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line"></span><br><span class="line">// 获取Library的目录路径</span><br><span class="line">NSString *libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line"></span><br><span class="line">// 获取应用程序程序包中资源文件路径</span><br><span class="line">NSString *bundle = [[NSBundle mainBundle] bundlePath];</span><br></pre></td></tr></table></figure><h3 id="2-NSFileManager"><a href="#2-NSFileManager" class="headerlink" title="2. NSFileManager"></a>2. NSFileManager</h3><ul><li>单例，提供 APP内 文件&amp;文件夹 管理功能</li><li>创建文件、删除文件、查询文件、移动和复制等</li><li>读取文件内容 &amp; 属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSString *cacheDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">    </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">// 创建GTData文件夹</span><br><span class="line">NSString *dirPath = [cacheDir stringByAppendingPathComponent:@&quot;GTData&quot;];</span><br><span class="line">    </span><br><span class="line">NSError *error;</span><br><span class="line">[fileManager createDirectoryAtPath:dirPath withIntermediateDirectories:YES attributes:nil error:&amp;error];</span><br><span class="line">    </span><br><span class="line">// 创建list文件</span><br><span class="line">NSString *filePath = [dirPath stringByAppendingPathComponent:@&quot;list&quot;];</span><br><span class="line">    </span><br><span class="line">NSData *fileData = [@&quot;我是数据&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    </span><br><span class="line">[fileManager createFileAtPath:filePath contents:fileData attributes:nil];</span><br><span class="line">    </span><br><span class="line">// 查询文件</span><br><span class="line">BOOL fileExist = [fileManager fileExistsAtPath:filePath];</span><br><span class="line">    </span><br><span class="line">// 删除文件</span><br><span class="line">if (fileExist) &#123;</span><br><span class="line">    [fileManager removeItemAtPath:filePath error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-NSFileHandle"><a href="#3-NSFileHandle" class="headerlink" title="3. NSFileHandle"></a>3. NSFileHandle</h3><ul><li>读取文件 &amp; 写文件</li><li>读取指定长度 &amp; 在指定位置追加/截取</li><li>截断 &amp; 立即刷新</li><li>常用于追加数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 像以上创建的文件追加内容</span><br><span class="line">NSFileHandle *fileHandle = [NSFileHandle fileHandleForUpdatingAtPath:filePath];</span><br><span class="line">[fileHandle seekToEndOfFile];</span><br><span class="line">[fileHandle writeData:[@&quot; 我是追加的内容&quot; dataUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line"></span><br><span class="line">// 更新文件并关闭handle</span><br><span class="line">[fileHandle synchronizeFile];</span><br><span class="line">[fileHandle closeFile];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 沙盒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5代码规范及屏幕适配</title>
      <link href="/2019/08/31/HTML5/HTML5%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
      <url>/2019/08/31/HTML5/HTML5%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>从事前端以来，遇到很多项目开发当中的问题，也积累了很多经验。</p><p>以下总结了前端代码编写规范和网页在不同屏幕大小的适配，目的在于让开发者规范自己的代码，不仅看起来清晰，也便于后期代码维护。</p><p>我们的目标是：走自己的路，也让别人有路可走~<br><a id="more"></a></p><h2 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h2><ul><li>所有命名小写</li><li>样式命名用“<code>-</code>”或“<code>_</code>”分割，比如：header-left，header_left</li><li>属性值用双引号(<code>&quot;&quot;</code>)包起来</li><li>标签层次排版规律工整</li><li>html 与 css 分离，html标签中最好不要出现样式</li><li><code>&lt;h1&gt;</code>到<code>&lt;h5&gt;</code>的定义，应遵循从大到小的原则，体现文档的结构，并有利于搜索引擎的查询</li><li>图片加上 <code>alt</code> 属性</li><li>命名尽量不缩写，尽量用英文表示</li><li>不要随便使用<code>id</code></li><li>样式命名不可太简单，也不可用标签名称命名，容易引起样式冲突，比如：left，top，p等，随口能蹦出来的名称</li><li>【很重要】<code>&lt;a&gt;</code>标签不可以包在块儿元素外层</li></ul><p><strong>开发中遇到的各种样式问题及解决方案，请访问：<a href="https://www.guoxb.com/2019/01/25/HTML5/HTML5%20%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">HTML5 笔记</a></strong></p><h2 id="2-计量单位"><a href="#2-计量单位" class="headerlink" title="2. 计量单位"></a>2. 计量单位</h2><h4 id="（1）计量单位一般有三种："><a href="#（1）计量单位一般有三种：" class="headerlink" title="（1）计量单位一般有三种："></a>（1）计量单位一般有三种：</h4><blockquote><ul><li>px：固定像素值</li><li>em：相对父级节点的<code>font-size</code>作为当前节点1em所代表的像素值</li><li>rem：相对根节点<code>html</code>的<code>font-size</code>作为当前节点1rem所代表的像素值</li></ul></blockquote><p>pc端大屏显示的网页，使用固定像素值；手机端小屏幕展示的网页，可以使用rem（看需求），em基本不用。</p><h4 id="（2）rem-的简单计算"><a href="#（2）rem-的简单计算" class="headerlink" title="（2）rem 的简单计算"></a>（2）rem 的简单计算</h4><p>一般浏览器默认的<code>html</code>字体大小是<code>font-size: 16px</code>，那么<code>1rem = 16px</code>，样式可以这么写：<code>font-size: 1rem;</code>。</p><p>那么<code>13px</code>是多少<code>rem</code>？？？算起来有些困难。</p><p>如果样式里所有像素值都这么算，这活儿就干不下去了。。。</p><p><strong>解决方案：</strong></p><p>第一种：使用less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@r: 10rem;</span><br><span class="line">.title &#123;font-size: 10/@r;&#125;</span><br></pre></td></tr></table></figure><p>样式查看是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">    font-size: 0.8125rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>less虽然可以解决这个问题，但是很不直观，不好维护。</p><p>第二种：换算一下，让<code>10px = 1rem</code></p><p>html页面所有标签样式单位依赖于html的<code>font-size</code>，所以让<code>font-size = 10px</code>即可</p><blockquote><p>但是，为了兼容性和未来发展趋势的综合考虑，px这个单位的含义已经越来越混乱，几乎无法评估以后的设备是会一直像现在这样对网页上的px做兼容处理，还是让px回归“像素”的本意<br>如果，设置html {font-size: 62.5%;}，1rem = 16px*62.5%=10px，14px=1.4rem；<br>而且，62.5%代表默认字体尺寸的62.5%，这个含义基本不会有混乱</p></blockquote><h2 id="3-屏幕适配"><a href="#3-屏幕适配" class="headerlink" title="3. 屏幕适配"></a>3. 屏幕适配</h2><p>随着互联网的快速发展，html5+css3也在迅速崛起，响应式布局也随之而出。</p><p>响应式布局可以兼容多个终端，做一个网站可能会运行在不同屏幕上，比如：PC，手机，iPad。</p><p>如果同时兼容3个终端，面对不同设备灵活性强，能够快速解决多设备显示的问题；但是，也有不能完全兼容所有浏览器，代码累赘，加载时间长以及不能完成所有内容都显示的缺点。</p><p>如何做到响应式布局？那就是通过媒体查询<code>@media</code>，通过判断终端设备宽度在哪个像素范围，执行不同的CSS样式。</p><h4 id="用rem对不同手机端屏幕适配"><a href="#用rem对不同手机端屏幕适配" class="headerlink" title="用rem对不同手机端屏幕适配"></a>用rem对不同手机端屏幕适配</h4><p>实现原理其实就是通过监听不同屏幕大小，去改变html的font-size大小</p><p>例如：现在一个文字 在375屏幕上大小是16px，在750屏幕上是32px，该怎么实现？直接上代码：</p><p>html 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是1.6rem字体<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是16px字体<span class="tag">&lt;<span class="name">span</span>&gt;</span>我是32px字体<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css 代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">62.5%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rem_p</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1.6rem</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rem_p</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">3.2rem</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.normal_p</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.normal_p</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>你会看到1.6rem和16px字体大小是一样的</p><p><img src="/2019/08/31/HTML5/HTML5代码规范及屏幕适配/normalweb.png" alt="页面展示"></p><p>现在屏幕改变是不会对字体大小产生作用的，下面通过js监听屏幕变化，改变html的font-size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * docEl: 获取页面html节点</span><br><span class="line"> * resizeEvt: 事件名称 orientationchange - 旋转屏幕  resize - 大小变化</span><br><span class="line"> * recalc: 改变html的fontSize函数</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">(function (doc, win) &#123;</span><br><span class="line">var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</span><br><span class="line">recalc = function () &#123;</span><br><span class="line">var clientWidth = docEl.clientWidth;</span><br><span class="line">if (!clientWidth) return;</span><br><span class="line">if (clientWidth &gt; 750) &#123;</span><br><span class="line">docEl.style.fontSize = &apos;125%&apos;; // 20px</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">docEl.style.fontSize = clientWidth / 37.5 + &apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">recalc();</span><br><span class="line">if (!doc.addEventListener) return;</span><br><span class="line">win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure><p>手机端屏幕大小 375 ~ 750 范围对应 html 的font-size大小在 10px ~ 20px，即 62.5% ~ 125%</p><p>引入js，查看页面</p><p><img src="/2019/08/31/HTML5/HTML5代码规范及屏幕适配/375web.png" alt="375屏幕下字体大小"></p><p><img src="/2019/08/31/HTML5/HTML5代码规范及屏幕适配/750web.png" alt="750屏幕下字体大小"></p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue环境搭建</title>
      <link href="/2019/07/21/Vue/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/07/21/Vue/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>创建一个Vue项目，遇到一些问题，比如：请求接口存在跨域问题怎么办？</p><p>这篇文章是我自学Vue遇到的一些问题及总结。</p><p>后续会不断更新…<br><a id="more"></a></p><h3 id="Vue环境搭建"><a href="#Vue环境搭建" class="headerlink" title="Vue环境搭建"></a>Vue环境搭建</h3><figure class="highlight plain"><figcaption><span>init webpack vuedemo01```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```vue init webpack-simple vuedemo01</span><br></pre></td></tr></table></figure><h3 id="Error-No-PostCSS-Config-found-in…"><a href="#Error-No-PostCSS-Config-found-in…" class="headerlink" title="Error: No PostCSS Config found in…"></a>Error: No PostCSS Config found in…</h3><p>项目在本地运行不报错，上传到码云，clone到本地安装依赖包，执行</p><p><code>npm run dev</code></p><p>报错 Error: No PostCSS Config found in…</p><p>解决方案：</p><p>在项目根目录新建 postcss.config.js 文件，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">plugins: &#123;</span><br><span class="line">&apos;autoprefixer&apos;: &#123;browsers: &apos;last 5 version&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新run，就好了~</p><p>postcss.config.js 是针对webpack3.0做的特殊处理~</p><h3 id="跨域问题-No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource"><a href="#跨域问题-No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource" class="headerlink" title="跨域问题 No ‘Access-Control-Allow-Origin’ header is present on the requested resource."></a>跨域问题 No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</h3><p>在vue中直接请求接口，会存在跨域问题。</p><p>解决方案：</p><p>例如请求的接口的路径为:</p><p><code>http://192.168.1.167:8080/api_v1/user/list</code></p><ol><li>根目录config-&gt;index.js配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">dev: &#123;</span><br><span class="line">...</span><br><span class="line">proxyTable: &#123;</span><br><span class="line">&apos;/cms_api&apos;: &#123;</span><br><span class="line">target: &apos;http://192.168.1.167:8080&apos;,</span><br><span class="line">changeOrigin: true,</span><br><span class="line">pathRewrite: &#123;</span><br><span class="line">&apos;^/cms_api&apos;: &apos;/api_v1/&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>请求接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.getToApi(</span><br><span class="line">&apos;cms_api/user/list&apos;,</span><br><span class="line">&#123;</span><br><span class="line">page: 1,</span><br><span class="line">limit: 20</span><br><span class="line">&#125;,</span><br><span class="line">result =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">err =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="组件构成部分"><a href="#组件构成部分" class="headerlink" title="组件构成部分"></a>组件构成部分</h3><p>props 传递数据、events 触发事件 和 slot 内容分发 构成Vue组件的3个API来源，再复杂的组件也是由这3部分构成。</p><h3 id="多层路由-跨域请求接口-问题"><a href="#多层路由-跨域请求接口-问题" class="headerlink" title="多层路由+跨域请求接口 问题"></a>多层路由+跨域请求接口 问题</h3><p>路由路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;/hospital/detail/:hospital_id&apos;, name: &apos;HosDetail&apos;, component: HosDetail &#125;</span><br></pre></td></tr></table></figure><p>config -&gt; index.js跨域配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &apos;/cms_api&apos;: &#123;</span><br><span class="line">        target: &apos;http://192.168.1.172:8080&apos;,</span><br><span class="line">        // target: &apos;http://localhost:8080&apos;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/cms_api&apos;: &apos;/hospitalpatrol/admin/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当在 HosDetail 组件下请求接口时，请求路径会变为</p><p><code>http://localhost:8080/hospital/detail/cms_api/department/hospital</code></p><p>而正常请求路径应该是</p><p><code>http://localhost:8080/cms_api/department/hospital</code></p><p>解决方案：请求拦截</p><p>在main.js中配置axios请求拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//请求拦截</span><br><span class="line">axios.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">  //请求之前重新拼装url</span><br><span class="line">  config.url = process.env.API_ROOT + config.url;</span><br><span class="line">  return config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="vue2-0-别人通过ip访问自己运行的项目-被拒绝"><a href="#vue2-0-别人通过ip访问自己运行的项目-被拒绝" class="headerlink" title="vue2.0 别人通过ip访问自己运行的项目 被拒绝"></a>vue2.0 别人通过ip访问自己运行的项目 被拒绝</h3><ol><li>在 config -&gt; index.js 文件中将 host 改为 0.0.0.0</li><li>在 package.json 文件中修改 dev ：</li></ol><p><code>&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --host 0.0.0.0&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue插件开发与发布</title>
      <link href="/2019/04/28/Vue/Vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
      <url>/2019/04/28/Vue/Vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>Vue.js 作为当下比较热门的技术，它的核心库只关注视图层，容易上手。组件是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义的元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以是原生HTML元素的形式，以js特性扩展。</p><p>这篇文章带你创建属于自己的组件库，并打包到 npm 供更多人使用。</p><a id="more"></a><h3 id="一、-创建-Vue-项目"><a href="#一、-创建-Vue-项目" class="headerlink" title="一、 创建 Vue 项目"></a>一、 创建 Vue 项目</h3><p>使用 vue-cli 脚手架创建项目 guoxb-ui</p><p><code>vue init webpack guoxb-ui</code></p><p>当然，也可以用 <code>vue init webpack-simple guoxb-ui</code> 创建简洁的项目</p><h3 id="二、-项目架构目录"><a href="#二、-项目架构目录" class="headerlink" title="二、 项目架构目录"></a>二、 项目架构目录</h3><p><img src="/2019/04/28/Vue/Vue组件开发与发布/ico_jiegou.png" alt="整体结构"></p><p>通过运行上述指令，生成的项目结构如图所示，大结构基本不用动，只需要添加自己的配置文件以及自己的文件夹即可。</p><p>添加的配置如下（从上至下依次拆分）：</p><h5 id="1-build-目录添加-webpack-dist-config-js"><a href="#1-build-目录添加-webpack-dist-config-js" class="headerlink" title="1. build 目录添加 webpack.dist.config.js"></a>1. build 目录添加 webpack.dist.config.js</h5><p>build 目录下存放着 webpack 的配置信息，在该目录下添加了一个单独打包插件的配置文件 webpack.dist.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">**entry: &apos;./src/plugin/index.js&apos;, // 入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;), // 打包后的文件放这里</span><br><span class="line">    publicPath: &apos;/dist/&apos;,</span><br><span class="line">    filename: &apos;guoxb-ui.js&apos;,</span><br><span class="line">    library: &apos;guoxb-ui&apos;, // library指定的是引入项目的模块名</span><br><span class="line">    libraryTarget: &apos;umd&apos;, // libraryTarget会生成不同umd的代码,可以只是commonjs标准的，也可以是指amd标准的，也可以只是通过script标签引入的（必须加上）</span><br><span class="line">    umdNamedDefine: true // 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define（必须加上）</span><br><span class="line">  &#125;,**</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;vue-style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.scss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;vue-style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.sass$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;vue-style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader?indentedSyntax&apos;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &apos;vue-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">            // Since sass-loader (weirdly) has SCSS as its default parse mode, we map</span><br><span class="line">            // the &quot;scss&quot; and &quot;sass&quot; values for the lang attribute to the right configs here.</span><br><span class="line">            // other preprocessors should work out of the box, no loader config like this necessary.</span><br><span class="line">            &apos;scss&apos;: [</span><br><span class="line">              &apos;vue-style-loader&apos;,</span><br><span class="line">              &apos;css-loader&apos;,</span><br><span class="line">              &apos;sass-loader&apos;</span><br><span class="line">            ],</span><br><span class="line">            &apos;sass&apos;: [</span><br><span class="line">              &apos;vue-style-loader&apos;,</span><br><span class="line">              &apos;css-loader&apos;,</span><br><span class="line">              &apos;sass-loader?indentedSyntax&apos;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">          // other vue-loader options go here</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif|svg)$/,</span><br><span class="line">        loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &apos;[name].[ext]?[hash]&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    noInfo: true,</span><br><span class="line">    overlay: true</span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: false</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &apos;#eval-source-map&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">  module.exports.devtool = &apos;#source-map&apos;</span><br><span class="line">  // http://vue-loader.vuejs.org/en/workflow/production.html</span><br><span class="line">  module.exports.plugins = (module.exports.plugins || []).concat([</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env&apos;: &#123;</span><br><span class="line">        NODE_ENV: &apos;&quot;production&quot;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      sourceMap: true,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      minimize: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码实际是 <code>npm init webpack-simple guoxb-ui</code> 生成项目中的 webpack.config.js 文件中的代码，我们只需要改的就是 入口文件 和 输出文件</p><h5 id="2-src下创建plugin文件夹，所有自定义组件都放这里"><a href="#2-src下创建plugin文件夹，所有自定义组件都放这里" class="headerlink" title="2. src下创建plugin文件夹，所有自定义组件都放这里"></a>2. src下创建plugin文件夹，所有自定义组件都放这里</h5><p><img src="/2019/04/28/Vue/Vue组件开发与发布/ico_jiegou3.png" alt="整体结构"></p><p>其中，button 文件夹存放 自定义的button组件 button.vue 以及 用于导出组件的 index.js；</p><p>plugin 目录下的 index.js 用于添加我们的组件内容，以及注册组件。</p><h6 id="plugin-gt-button-gt-button-vue-源码"><a href="#plugin-gt-button-gt-button-vue-源码" class="headerlink" title="plugin -&gt; button -&gt; button.vue 源码"></a>plugin -&gt; button -&gt; button.vue 源码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">      class=&quot;guoxb-button&quot;</span><br><span class="line">      :class=&quot;[&apos;guoxb-button--&apos; + type, &apos;guoxb-button--&apos; + (round ? &apos;round&apos; : &apos;&apos;)]&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;g-button&quot;, // *** 我们是全局注入组件，所以在后面引入我们的组件后，会使用这个命名的标签 ***</span><br><span class="line">  props: &#123;</span><br><span class="line">    type: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;normal&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    round: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.guoxb-button &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  color: #f68;</span><br><span class="line">  background: #fff;</span><br><span class="line">  border: 1px solid #eee;</span><br><span class="line">&#125;</span><br><span class="line">.guoxb-button--normal &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">&#125;</span><br><span class="line">.guoxb-button--small &#123;</span><br><span class="line">  width: 80px;</span><br><span class="line">  line-height: 30px;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line">.guoxb-button--large &#123;</span><br><span class="line">  width: 120px;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.guoxb-button--round &#123;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="plugin-gt-button-gt-index-js-源码"><a href="#plugin-gt-button-gt-index-js-源码" class="headerlink" title="plugin -&gt; button -&gt; index.js 源码"></a>plugin -&gt; button -&gt; index.js 源码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; default &#125; from &apos;./button.vue&apos;;</span><br></pre></td></tr></table></figure><h6 id="plugin-gt-index-js-源码"><a href="#plugin-gt-index-js-源码" class="headerlink" title="plugin -&gt; index.js 源码"></a>plugin -&gt; index.js 源码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import GButton from &apos;./button&apos;;</span><br><span class="line">import *** from &apos;./***&apos;;</span><br><span class="line"></span><br><span class="line">const install = function(Vue, options) &#123;</span><br><span class="line">    if (install.installed) return;</span><br><span class="line">    Vue.component(GButton.name, GButton);</span><br><span class="line">    Vue.component(***.name, ***);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 支持使用标签的方式引入 */</span><br><span class="line">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class="line">    install(window.Vue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    install,</span><br><span class="line">    GButton,</span><br><span class="line">    ***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="疑问：为什么在button文件夹下还要创建index-js"><a href="#疑问：为什么在button文件夹下还要创建index-js" class="headerlink" title="疑问：为什么在button文件夹下还要创建index.js"></a>疑问：为什么在button文件夹下还要创建index.js</h6><p><img src="/2019/04/28/Vue/Vue组件开发与发布/1556517520350.jpg" alt="为什么在button文件夹下还要创建index.js"></p><p>这是从网上找到的答案，可能并没有太大说服力，所以又仔细的查看了<a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">vue官方文档</a></p><blockquote><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：<br>(1) 添加全局方法或者属性。如: vue-custom-element<br>(2) 添加全局资源：指令/过滤器/过渡等。如 vue-touch<br>(3) 通过全局混入来添加一些组件选项。如 vue-router<br>(4) 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br>(5) 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</p></blockquote><p>不难理解，当我们的组件需要为Vue添加全局功能的时候，是需要在index.js导出组件之前，来完成这步操作的！</p><p>所以，官方文档也给出了为Vue添加全局功能的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = function (Vue, options) &#123;</span><br><span class="line">  // 1. 添加全局方法或属性</span><br><span class="line">  Vue.myGlobalMethod = function () &#123;</span><br><span class="line">    // 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 添加全局资源</span><br><span class="line">  Vue.directive(&apos;my-directive&apos;, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      // 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 3. 注入组件选项</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: function () &#123;</span><br><span class="line">      // 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 4. 添加实例方法</span><br><span class="line">  Vue.prototype.$myMethod = function (methodOptions) &#123;</span><br><span class="line">    // 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是要写在组件内部的 index.js 里面的。</p><h3 id="三、-测试组件"><a href="#三、-测试组件" class="headerlink" title="三、 测试组件"></a>三、 测试组件</h3><p>在任一页面引入组件，作测试，例如：</p><p>在src - components - HelloWorld.vue 下引入组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">   &lt;g-button :round=&quot;true&quot; type=&quot;normal&quot;&gt;按钮&lt;/g-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">/* 打包前的组件测试 */</span><br><span class="line">import GuoUI from &apos;@/plugin/index.js&apos;;</span><br><span class="line">/* 打包后的组件测试(打包后，会在项目根目录生成dist文件夹) */</span><br><span class="line">// import GuoUI from &apos;../../dist/guoxb-ui.js&apos;;</span><br><span class="line">Vue.use(GuoUI);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HelloWorld&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行项目，测试组件</p><h3 id="四、-打包"><a href="#四、-打包" class="headerlink" title="四、 打包"></a>四、 打包</h3><p>这里需要修改 package.json 文件，如图所示：</p><p><img src="/2019/04/28/Vue/Vue组件开发与发布/WX20190429-144512.png" alt="package.json"></p><ul><li>main属性：打包到dist下的文件，也是以后安装引用使用的js文件</li><li>scripts 中添加 <code>&quot;dist&quot;: &quot;webpack --config build/webpack.dist.config.js&quot;</code> 用于打包</li><li>repository 仓库，可以不写，如果不写，npm官网就没有跳到你github上的入口</li></ul><p>做完以上配置，控制台输入 <code>npm run dist</code> 开始打包，打包成功后，会在项目根目录生成 dist 文件夹，里面是package.json -&gt; main属性配置的 guoxb-ui.js 文件</p><p>可以再引入 dist 下的 guoxb-ui.js 文件测试组件</p><h3 id="五、-发布组件"><a href="#五、-发布组件" class="headerlink" title="五、 发布组件"></a>五、 发布组件</h3><p>测试ok了，接下来就是发布组件到 npm，首先得有npm账号，如果没有请走注册。</p><p>控制台，项目根目录下，执行命令：<code>npm login</code> 登录 npm，此时会让输入用户名、密码以及邮箱；</p><p>登录成功之后，执行命令：<code>npm publish</code> 即可。</p><p>记住，每次发布，需要修改 package.json 版本号，不然报错。</p><p>发布完之后，就可以转到我们的 npm官网 上查看我们的项目。</p><p><a href="https://www.npmjs.com/package/guoxb-ui" target="_blank" rel="noopener">https://www.npmjs.com/package/guoxb-ui</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript 6.0</title>
      <link href="/2019/03/18/Javascript/ES6.0/"/>
      <url>/2019/03/18/Javascript/ES6.0/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 6.0（简称ES6）是JavaScript语言的下一代标准，在2015年6月正式发布，目标是使得JavaScript语言可以实现复杂的大型应用程序，成为企业级开发语言。</p><p>先说一下 ECMAScript 和 JavaScript 的关系：JavaScript 是 Netscape 公司创造的；ECMAScript 是 ECMA标准化组织规定的浏览器脚本语言标准。可以说，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。<br><a id="more"></a></p><h3 id="一、let-amp-const"><a href="#一、let-amp-const" class="headerlink" title="一、let &amp; const"></a>一、let &amp; const</h3><h4 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h4><p>let 和 var 类似，都是用来声明变量，只是 let 所声明的变量，只在 let 命令所在的代码块内有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let numA = 10;</span><br><span class="line">var numB = 20;</span><br><span class="line">&#125;</span><br><span class="line">console.log(numA); // numA is not defined.</span><br><span class="line">console.log(numB); // 20</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">let i = &apos;abc&apos;;</span><br><span class="line">console.log(i); // abc</span><br><span class="line">&#125;</span><br><span class="line">// 函数内部变量i 与 循环变量i 不在同一个作用域</span><br></pre></td></tr></table></figure><h4 id="2-不存在变量提升"><a href="#2-不存在变量提升" class="headerlink" title="2. 不存在变量提升"></a>2. 不存在变量提升</h4><p>var 会发生“变量提升”，即变量可以在声明之前使用，值为undefined。而let 只能在声明之后使用，否则会报错。 </p><h4 id="3-const"><a href="#3-const" class="headerlink" title="3. const"></a>3. const</h4><p>const 声明一个只读的常量，一旦声明，值就不能改变</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python高级特性</title>
      <link href="/2019/02/21/Python/Python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2019/02/21/Python/Python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。<br>计算机工作的CPU只认识机器指令，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。<br>比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。<br>所以Python是一种相当高级的语言。</p><a id="more"></a><h3 id="1-切片"><a href="#1-切片" class="headerlink" title="1. 切片"></a>1. 切片</h3><p>从数组取值是非常常见的操作，如果取一个数组前3个元素，可以通过切片截取元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; L[0:3] # 0和3都是索引，索引为0可以省略L[:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br><span class="line"># 需要注意的是，Python支持L[-1]获取倒数第一个元素，同样支持倒数切片，记住倒数第一个元素的索引是-1</span><br><span class="line"></span><br><span class="line"># 前10个数，每两个取一个：</span><br><span class="line">&gt;&gt;&gt; L[0:10:2]</span><br><span class="line"># 所有数，每5个取一个</span><br><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line"># 原样复制一个list</span><br><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line"># 字符串也可以通过切片截取字符串，相当于substring</span><br></pre></td></tr></table></figure><h3 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h3><p>循环遍历 即为 迭代 (for in)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 迭代字典</span><br><span class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">&gt;&gt;&gt; print key</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; for value in d.values():</span><br><span class="line">&gt;&gt;&gt; print value</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; for k,v in d.items()</span><br><span class="line">&gt;&gt;&gt; print k + v</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"># 字符串也可作为迭代对象</span><br><span class="line">&gt;&gt;&gt; for ch in &apos;ABC&apos;:</span><br><span class="line">&gt;&gt;&gt; print(ch)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"># 只要作为一个迭代对象，for循环就可以正常运行，通过collections模块的Iterable类型判断是否是迭代对象：</span><br><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="3-列表生成式"><a href="#3-列表生成式" class="headerlink" title="3. 列表生成式"></a>3. 列表生成式</h3><p>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><p>但如果要生成[1x1, 2x2, 3x3, …, 9x9]怎么做？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生成式</span><br><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><span class="line"></span><br><span class="line"># for 循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</span><br><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br><span class="line"></span><br><span class="line"># 还可以使用两层循环，可以生成全排列：</span><br><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/2019/02/21/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/02/21/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。<br>计算机工作的CPU只认识机器指令，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。<br>比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。<br>所以Python是一种相当高级的语言。</p><a id="more"></a><h3 id="1-直接运行py文件"><a href="#1-直接运行py文件" class="headerlink" title="1. 直接运行py文件"></a>1. 直接运行py文件</h3><p>在Windows系统上是不行的，但是在Mac和Linux上是可以的，方法是</p><p>(1)在.py文件的第一行加上一个特殊的注释：</p><p><code>#!/usr/bin/env python3</code></p><p>(2)然后，通过命令给.py文件以执行权限：</p><p><code>$ chmod a+x *.py</code></p><p>之后在终端直接<code>./*.py</code>即可运行</p><h3 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h3><p>布尔类型为True 或 False；<br>空值为None，不能理解为0，因为0是有意义的，None是一个特殊的空值</p><h3 id="3-运算"><a href="#3-运算" class="headerlink" title="3. 运算"></a>3. 运算</h3><p>/ 除法，计算结果是浮点数，即使两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure><p>// 地板除，结果永远是整数，只取结果的整数部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="4-编码"><a href="#4-编码" class="headerlink" title="4. 编码"></a>4. 编码</h3><p>Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br></pre></td></tr></table></figure><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上:</p><p><code># -*- coding: utf-8 -*-</code></p><p>这行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h3 id="5-格式化字符串"><a href="#5-格式化字符串" class="headerlink" title="5. 格式化字符串"></a>5. 格式化字符串</h3><p>(1)使用%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure><p>%d    整数</p><p>%f    浮点数</p><p>%s    字符串</p><p>%x    十六进制整数</p><p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</span><br><span class="line">&apos;growth rate: 7 %&apos;</span><br></pre></td></tr></table></figure><p>（2）format()</p><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&apos;.format(&apos;小明&apos;, 17.125)</span><br><span class="line">&apos;Hello, 小明, 成绩提升了 17.1%&apos;</span><br></pre></td></tr></table></figure><h3 id="6-list-数组（有序，可变）"><a href="#6-list-数组（有序，可变）" class="headerlink" title="6. list-数组（有序，可变）"></a>6. list-数组（有序，可变）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">// （1）添加元素</span><br><span class="line">&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br><span class="line">// （2）插入元素</span><br><span class="line">&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br><span class="line">// （3）删除元素</span><br><span class="line">pop()删除末尾；pop(i)删除指定索引元素</span><br><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&apos;Adam&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&apos;Jack&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><h3 id="7-tuple元组（有序，不可变）"><a href="#7-tuple元组（有序，不可变）" class="headerlink" title="7. tuple元组（有序，不可变）"></a>7. tuple元组（有序，不可变）</h3><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，元组使用“()”,而不是“[]”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure><p>*如果元组只有一个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1) // 结果是1这个数字，而不是元组</span><br><span class="line">&gt;&gt;&gt; t = (1,) // 代表一个数的元组</span><br></pre></td></tr></table></figure><h3 id="8-dict-字典"><a href="#8-dict-字典" class="headerlink" title="8. dict-字典"></a>8. dict-字典</h3><p>（1）判断key是否存在<br>判断key是否存在，使用in</p><p><code>&#39;key&#39; in dict</code> 返回True 或 False</p><p>或者使用get()</p><p><code>dict.get(&#39;key&#39;)</code> 如果不存在，返回None</p><p>（2）删除key，使用pop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict.pop(&apos;key&apos;)</span><br><span class="line">75</span><br></pre></td></tr></table></figure><h3 id="9-set-集合（无序，元素不重复）"><a href="#9-set-集合（无序，元素不重复）" class="headerlink" title="9.set-集合（无序，元素不重复）"></a>9.set-集合（无序，元素不重复）</h3><p>（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>通过 add(key) 方法可以添加元素</p><p>通过 remove(key) 方法删除元素</p><p>（2）set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h3 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h3><p>（1）定义函数 def</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">if x &gt;= 0:</span><br><span class="line">return x</span><br><span class="line">else:</span><br><span class="line">return -x</span><br></pre></td></tr></table></figure><p>（2）空函数</p><p>pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>pass还可以用在其他语句里，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 10:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>（3）参数检查</p><p>对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>（4）默认参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=4, city=&apos;BeiJing&apos;):</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; enroll(&apos;guoxb&apos;, &apos;F&apos;)</span><br><span class="line">&gt;&gt;&gt; enroll(&apos;guoxb&apos;, &apos;F&apos;, city=&apos;HeBei&apos;)</span><br></pre></td></tr></table></figure><ul><li>定义默认参数要牢记：默认参数必须指向不变对象！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure><p>以上代码明显是有问题的，要修改上面的例子，我们可以用None这个不变对象来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>（5）可变参数</p><ul><li>定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 请计算a2 + b2 + c2 + …</span><br><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum </span><br><span class="line"># 但是调用的时候，需要先组装出一个list或tuple：</span><br><span class="line">&gt;&gt;&gt; calc( [1, 2, 3] )</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc( (1, 3, 5, 7) )</span><br><span class="line">84</span><br><span class="line"></span><br><span class="line"># 如果利用可变参数，调用函数的方式可以简化成这样：</span><br><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br><span class="line"></span><br><span class="line"># 函数的参数改为可变参数：</span><br><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line">    </span><br><span class="line"># 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</span><br><span class="line"># Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</span><br><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>（6）关键字参数</p><ul><li>定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 函数person除了必选参数name和age外，还接受关键字参数kw</span><br><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 可以传入任意个数的关键字参数：</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line"></span><br><span class="line"># 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</span><br><span class="line"></span><br><span class="line"># 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line"></span><br><span class="line"># **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</span><br></pre></td></tr></table></figure><p>（7）命名关键字参数</p><ul><li>定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。</span><br><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">    </span><br><span class="line"># 调用方式如下：</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br><span class="line"></span><br><span class="line"># 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</span><br><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure><p>（8）参数组合</p><ul><li>定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。</li><li>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br></pre></td></tr></table></figure><p>（9）小结</p><ul><li><code>*args是可变参数，args接收的是一个tuple；</code></li><li><code>**kw是关键字参数，kw接收的是一个dict。</code></li><li><code>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；</code></li><li><code>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云部署git-检出代码</title>
      <link href="/2019/02/16/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2git-%E6%A3%80%E5%87%BA%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/02/16/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2git-%E6%A3%80%E5%87%BA%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>用hexo在github上搭建了一个个人博客，本想写几篇文章被百度收录一下，过来很久去百度搜索，发现都没有被收录。</p><p>后来才知道，原来github上是拒绝被爬虫爬取的。那该怎么办？</p><a id="more"></a><p>是不是把代码迁移出github就可以了？总之前前后后试了很多种办法，在这里为大家推荐三种方法：</p><ul><li>Coding代码托管</li></ul><p>这种办法可行，而且是免费的，但是存在很大的不稳定性，因为访问网站很慢，后来在终端ping了一下，发现丢包很严重，果断放弃！</p><ul><li>码云</li></ul><p>很强大，部署上去访问速度也很快，如果不想花钱，那么域名只能是**.io；如果想自定义域名，需要花钱，不到100元搞定，而且可以试用一个月，很ok的，但是需要花钱，也放弃了！</p><ul><li>阿里云服务器</li></ul><p>因为本人有阿里云服务器，所以就开始研究如何将代码部署到阿里云服务器。因为hexo生成的是静态网页，尝试使用upload上传工具上传到服务器，配置nginx访问，非常完美！美中不足的是每次修改都需要用工具上传，太繁琐，于是就研究在阿里云部署git~~~</p><p>可以浏览下我的网站：<a href="http://guoxb.com/" title="我的博客">夜雨寒</a></p><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h3><p>本地终端通过<code>ssh manager@47.**.**.**</code>登录阿里云服务器，安装git</p><p><code>$ yum install git</code></p><h3 id="2-创建一个用户组-git"><a href="#2-创建一个用户组-git" class="headerlink" title="2. 创建一个用户组-git"></a>2. 创建一个用户组-git</h3><p><code>$ groupadd git</code></p><p>在用户组下创建一个用户，名字为git</p><p><code># adduser git -g git</code></p><p>给git分配一个密码</p><p><code>$ passwd git</code> 之后输入密码即可</p><h3 id="3-公钥"><a href="#3-公钥" class="headerlink" title="3. 公钥"></a>3. 公钥</h3><p>在服务器创建文件，配置公钥，用于git提交时免登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/git/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ chmod 700 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br><span class="line">$ chmod 600 .ssh/authorized_keys</span><br><span class="line">$ chown -R git:git .ssh</span><br></pre></td></tr></table></figure><p>其中<code>/home/git</code>目录为服务器上用户git的主页目录，上述操作相当于在<code>/home/git/.ssh/</code>目录下新建一个<code>authorized_keys</code>文件。并把目录.ssh的权限设置为700，<code>authorized_keys</code>文件权限设置为600。</p><p>因为git的pull相当于读操作，push相当于写操作，所以需要读写权限。<br>复制客户端公钥到服务器<code>authorized_keys</code>文件</p><h3 id="4-服务器端初始化git仓库"><a href="#4-服务器端初始化git仓库" class="headerlink" title="4. 服务器端初始化git仓库"></a>4. 服务器端初始化git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/data</span><br><span class="line">$ mkdir gitroot</span><br><span class="line">$ chown git:git gitroot/</span><br><span class="line">$ cd gitroot</span><br><span class="line">$ git init --bare demo.git</span><br><span class="line">$ chown -R git:git demo.git</span><br></pre></td></tr></table></figure><p>现在可以在客户端克隆仓库</p><p><code>git clone git@xxx.xxx.xxx.xxx:/home/data/gitroot/demo.git</code></p><p>相信很多人和我一样，不仅仅是为了创建一个git仓库供大家使用就ok了；很多时候，我们需要上传的项目代码，例如：静态网页等，需要去使用。继续。。</p><h3 id="5-钩子设置-找到我们的代码"><a href="#5-钩子设置-找到我们的代码" class="headerlink" title="5. 钩子设置-找到我们的代码"></a>5. 钩子设置-找到我们的代码</h3><p>利用git的<code>hooks</code>中的<code>post-receive</code>来实现代码提交完成之后的动作。将仓库指定一个<code>--work-tree</code>然后进行检出操作<code>checkout --force</code></p><p>在<code>/home/data/gitroot/demo.git</code>目录下，有一个hooks文件夹，编辑里面的<code>root-receive</code>文件，如果没有可以创建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/gitroot/demo.git/hooks</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure><p>在 post-receive 文件增加下面两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 指定我的代码检出目录</span><br><span class="line">DIR=/home/demo</span><br><span class="line">git --work-tree=$&#123;DIR&#125; clean -fd</span><br><span class="line"># 直接强制检出</span><br><span class="line">git --work-tree=$&#123;DIR&#125; checkout --force</span><br></pre></td></tr></table></figure><p>这里需要注意一下：</p><p><code>/home/demo</code> 目录需要手动去创建，并要给与较高的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">chmod 777 demo</span><br></pre></td></tr></table></figure><p>最后，在客户端push我们的代码，就可以在服务器端 <code>/home/demo</code>目录下看到我们上传的代码了。</p><p>可以浏览下我的网站：<a href="http://guoxb.com/" title="我的博客">夜雨寒</a></p>]]></content>
      
      
      <categories>
          
          <category> 阿里云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 笔记</title>
      <link href="/2019/01/25/HTML5/HTML5%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/25/HTML5/HTML5%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习html5以来，遇到很多项目中的问题，以下是个人总结的知识点，这些点在项目开发中经常遇到，希望对大家有所帮助~<br><a id="more"></a></p><h3 id="1-li-撑不起ul-可以在ul最下面添加如下代码"><a href="#1-li-撑不起ul-可以在ul最下面添加如下代码" class="headerlink" title="1. li 撑不起ul 可以在ul最下面添加如下代码"></a>1. <code>li</code> 撑不起<code>ul</code> 可以在<code>ul</code>最下面添加如下代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:0;overflow:hidden;clear:both;&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 或者</span><br><span class="line">.clearfix &#123; *zoom: 1;  &#125;</span><br><span class="line">.clearfix:after &#123; content: ‘’; display: block; clear: both; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-浏览器兼容"><a href="#2-浏览器兼容" class="headerlink" title="2. 浏览器兼容"></a>2. 浏览器兼容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-ms-box-sizing:border-box;   //IE</span><br><span class="line">-moz-box-sizing:border-box;   //Firefox</span><br><span class="line">-webkit-box-sizing:border-box;</span><br><span class="line">box-sizing:border-box;</span><br></pre></td></tr></table></figure><h3 id="3-移动端css—加上如下代码"><a href="#3-移动端css—加上如下代码" class="headerlink" title="3. 移动端css—加上如下代码"></a>3. 移动端css—加上如下代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button,select&#123;background:transparent; -webkit-appearance:none;&#125;</span><br><span class="line">input, button, select, textarea&#123;outline:none !important;&#125;</span><br><span class="line">textarea&#123;resize: none;&#125;</span><br><span class="line">input:focus, button:focus, select:focus, textarea:focus&#123;box-shadow:none !important; outline:none !important;&#125;</span><br><span class="line"></span><br><span class="line">// 取消手机点击屏幕时，会出现的灰块</span><br><span class="line">html,body&#123;-webkit-text-size-adjust: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;</span><br></pre></td></tr></table></figure><h3 id="4-文本显示不全，后面显示…"><a href="#4-文本显示不全，后面显示…" class="headerlink" title="4. 文本显示不全，后面显示…"></a>4. 文本显示不全，后面显示…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: block; overflow:hidden;word-break:keep-all;white-space:nowrap;text-overflow:ellipsis;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;换行</span><br><span class="line">white-space: normal; word-break: break-all;</span><br></pre></td></tr></table></figure><h3 id="5-百分比-px"><a href="#5-百分比-px" class="headerlink" title="5. 百分比-px"></a>5. 百分比-<code>px</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width: -webkit-calc( 100% - 70px ); width: calc( 100% - 70px );</span><br></pre></td></tr></table></figure><h3 id="6-文本太长省略。。。"><a href="#6-文本太长省略。。。" class="headerlink" title="6. 文本太长省略。。。"></a>6. 文本太长省略。。。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;  text-overflow:ellipsis; white-space:nowrap;</span><br></pre></td></tr></table></figure><h3 id="7-textarea-高度随文本变化"><a href="#7-textarea-高度随文本变化" class="headerlink" title="7. textarea 高度随文本变化"></a>7. <code>textarea</code> 高度随文本变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea style=&quot;overflow: hidden; font-style: normal; font-size: 14px; line-height: normal; &quot; rows=&quot;1&quot; cols=&quot;30&quot; onfocus=&quot;javascript:ResizeTextarea(this,1);&quot; onclick=&quot;javascript:ResizeTextarea(this,1);&quot; onkeyup=&quot;javascript:ResizeTextarea(this,1);&quot;&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">textarea&#123;min-height: 33px; max-height: 65px; padding: 0; border: 0; width: -webkit-calc( 100% - 20px ); width: calc( 100% - 20px ); margin: 6px 0; border-radius: 5px; padding: 7px;&#125;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var agt = navigator.userAgent.toLowerCase();</span><br><span class="line">var is_op = (agt.indexOf(&quot;opera&quot;) != -1);</span><br><span class="line">var is_ie = (agt.indexOf(&quot;msie&quot;) != -1) &amp;&amp; document.all &amp;&amp; !is_op;</span><br><span class="line">function ResizeTextarea(a,row)&#123;</span><br><span class="line">    if(!a)&#123;return&#125;</span><br><span class="line">    if(!row)</span><br><span class="line">        row=5;</span><br><span class="line">    var b=a.value.split(&quot;\n&quot;);</span><br><span class="line">    var c=is_ie?1:0;</span><br><span class="line">    c+=b.length;</span><br><span class="line">    var d=a.cols;</span><br><span class="line">    if(d&lt;=20)&#123;d=40&#125;</span><br><span class="line">    for(var e=0;e&lt;b.length;e++)&#123;</span><br><span class="line">        if(b[e].length&gt;=d)&#123;</span><br><span class="line">            c+=Math.ceil(b[e].length/d)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c=Math.max(c,row);</span><br><span class="line">    if(c!=a.rows)&#123;</span><br><span class="line">        a.rows=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="8-手机端打开h5页面，点击a标签会有阴影的问题"><a href="#8-手机端打开h5页面，点击a标签会有阴影的问题" class="headerlink" title="8. 手机端打开h5页面，点击a标签会有阴影的问题"></a>8. 手机端打开h5页面，点击a标签会有阴影的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对a标签 添加样式 -webkit-tap-highlight-color:transparent;</span><br></pre></td></tr></table></figure><h3 id="9-模糊-【毛玻璃】"><a href="#9-模糊-【毛玻璃】" class="headerlink" title="9. 模糊 -【毛玻璃】"></a>9. 模糊 -【毛玻璃】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.blur &#123;</span><br><span class="line">    filter: url(blur.svg#blur); /* FireFox, Chrome, Opera */</span><br><span class="line">    -webkit-filter: blur(10px); /* Chrome, Opera */</span><br><span class="line">    -moz-filter: blur(10px);</span><br><span class="line">    -ms-filter: blur(10px);    </span><br><span class="line">    filter: blur(10px);</span><br><span class="line"> filter:progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-修复H5-Button-颜色异常问题"><a href="#10-修复H5-Button-颜色异常问题" class="headerlink" title="10. 修复H5 Button 颜色异常问题"></a>10. 修复H5 <code>Button</code> 颜色异常问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appearance:square-button;</span><br><span class="line">-moz-appearance:square-button; /* Firefox */</span><br><span class="line">-webkit-appearance:square-button; /* Safari 和 Chrome */</span><br></pre></td></tr></table></figure><h3 id="11-获取url后面的参数值"><a href="#11-获取url后面的参数值" class="headerlink" title="11. 获取url后面的参数值"></a>11. 获取url后面的参数值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function UrlValue(name) &#123;</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    if (r != null) return unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中文乱码问题</span><br><span class="line"></span><br><span class="line">function UrlValue(name) &#123;</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    if (r != null) return decodeURI(r[2]); return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-获取第几个到第几个元素"><a href="#12-获取第几个到第几个元素" class="headerlink" title="12. 获取第几个到第几个元素"></a>12. 获取第几个到第几个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.cls_list ul li&apos;).slice(li_length-3, li_length).css(&apos;border-bottom&apos;, &apos;none&apos;);</span><br></pre></td></tr></table></figure><h3 id="13-渐变"><a href="#13-渐变" class="headerlink" title="13. 渐变"></a>13. 渐变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#grad1 &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">    background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">    background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">    background: linear-gradient(red, blue); /* 标准的语法（必须放在最后） */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-置顶"><a href="#14-置顶" class="headerlink" title="14. 置顶"></a>14. 置顶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function scrollToTop()&#123;</span><br><span class="line">    $(&apos;body,html&apos;).animate(&#123; scrollTop: 0 &#125;, 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-document-on-在Safari浏览器不能用的问题解决方案"><a href="#15-document-on-在Safari浏览器不能用的问题解决方案" class="headerlink" title="15. $(document).on()在Safari浏览器不能用的问题解决方案"></a>15. <code>$(document).on()</code>在Safari浏览器不能用的问题解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击的元素加样式cursor: pointer;</span><br></pre></td></tr></table></figure><h3 id="16-Safari浏览器点击数字自动拨打电话"><a href="#16-Safari浏览器点击数字自动拨打电话" class="headerlink" title="16. Safari浏览器点击数字自动拨打电话"></a>16. Safari浏览器点击数字自动拨打电话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="17-引入自定义字体"><a href="#17-引入自定义字体" class="headerlink" title="17. 引入自定义字体"></a>17. 引入自定义字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">font-family: &apos;FZZZHJT&apos;;</span><br><span class="line">src: url(&apos;../font/FZZZHJT.eot&apos;);</span><br><span class="line">src:</span><br><span class="line">    url(&apos;../font/FZZZHJT.eot?#font-spider&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">    /*url(&apos;../font/FZZDHJT.woff&apos;) format(&apos;woff&apos;),*/</span><br><span class="line">    url(&apos;../font/FZZZHJT.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">    url(&apos;../font/FZZZHJT.svg&apos;) format(&apos;svg&apos;);</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  font-style: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-与客户端交互"><a href="#18-与客户端交互" class="headerlink" title="18. 与客户端交互"></a>18. 与客户端交互</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var ios_bridge = null;</span><br><span class="line">connectWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    /* Init your app here */</span><br><span class="line">    if(bridge) &#123;</span><br><span class="line">        ios_bridge = bridge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">function connectWebViewJavascriptBridge(callback)&#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        callback(WebViewJavascriptBridge)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function() &#123;</span><br><span class="line">            callback(WebViewJavascriptBridge)</span><br><span class="line">        &#125;, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 开启试管之旅</span><br><span class="line">function openTubeTour()&#123;</span><br><span class="line">if(window.JavascriptInterface &amp;&amp; window.JavascriptInterface[func_tag])&#123;</span><br><span class="line">window.JavascriptInterface.gotoDoctor(tag_id, tag_name)</span><br><span class="line">&#125;</span><br><span class="line">if(ios_bridge)&#123;</span><br><span class="line">ios_bridge.send(&#123;tag:&quot;gotoTopic&quot;, topic_id:topic_id&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-jquery-拷贝数组"><a href="#19-jquery-拷贝数组" class="headerlink" title="19. jquery 拷贝数组"></a>19. jquery 拷贝数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].concat(new_arr);</span><br></pre></td></tr></table></figure><h3 id="20-透明度"><a href="#20-透明度" class="headerlink" title="20. 透明度"></a>20. 透明度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter:alpha(opacity=70); -moz-opacity:0.7; opacity:0.7;</span><br></pre></td></tr></table></figure><h3 id="21-中心平移法解决划线粗的问题"><a href="#21-中心平移法解决划线粗的问题" class="headerlink" title="21. 中心平移法解决划线粗的问题"></a>21. 中心平移法解决划线粗的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ctx = document.getElementById(&apos;scroll_canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">ctx.translate(0.5,0.5);</span><br></pre></td></tr></table></figure><h3 id="22-整屏滚动"><a href="#22-整屏滚动" class="headerlink" title="22. 整屏滚动"></a>22. 整屏滚动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jquery.fullPage.min.js 这个插件可以实现一屏一屏的滚动</span><br></pre></td></tr></table></figure><h3 id="23-滚动停止监听方法"><a href="#23-滚动停止监听方法" class="headerlink" title="23. 滚动停止监听方法"></a>23. 滚动停止监听方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var timer;</span><br><span class="line"></span><br><span class="line">window.onscroll=function()&#123;</span><br><span class="line">    if(timer)</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    </span><br><span class="line">    timer = setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;scrolling ends..&apos;)</span><br><span class="line">        //TODO some codes here</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-隐藏滚动条"><a href="#24-隐藏滚动条" class="headerlink" title="24. 隐藏滚动条"></a>24. 隐藏滚动条</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.class::-webkit-scrollbar &#123;</span><br><span class="line">    background: transparent;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0;</span><br><span class="line">&#125;</span><br><span class="line">// https://segmentfault.com/q/1010000000204586</span><br></pre></td></tr></table></figure><h3 id="25-对象深拷贝"><a href="#25-对象深拷贝" class="headerlink" title="25. 对象深拷贝"></a>25. 对象深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(source) &#123; </span><br><span class="line">    var result = &#123;&#125;;</span><br><span class="line">    for (var key in source) &#123;</span><br><span class="line">        result[key] = typeof source[key] === &apos;object&apos;? deepCopy(source[key]): source[key];</span><br><span class="line">    &#125; </span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-sel查找控件"><a href="#26-sel查找控件" class="headerlink" title="26. sel查找控件"></a>26. sel查找控件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; min=&quot;10&quot; max=&quot;1000&quot; step=&quot;10&quot; value=&quot;500&quot; data-rangeslider&gt;</span><br><span class="line"></span><br><span class="line">var $document   = $(document);</span><br><span class="line">var selector    = &apos;[data-rangeslider]&apos;;</span><br><span class="line">var $inputRange = $(selector);</span><br></pre></td></tr></table></figure><h3 id="27-将html代码中-lt-img-gt-替换"><a href="#27-将html代码中-lt-img-gt-替换" class="headerlink" title="27. 将html代码中&lt;img&gt;替换"></a>27. 将html代码中<code>&lt;img&gt;</code>替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text_html = document.getElementById(&apos;saytext&apos;).innerHTML;</span><br><span class="line">text_html = text_html.replace(/&lt;img [^&gt;]*src=[&apos;&quot;]([^&apos;&quot;]+)[^&gt;]*&gt;/gi,function(match, capture)&#123;</span><br><span class="line">var newStr = &apos;[em_&apos; + capture.substring(capture.indexOf(&apos;/&apos;) + 1, capture.indexOf(&apos;.&apos;)) + &apos;]&apos;;</span><br><span class="line">return newStr;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="28-输入框文本输入实时监听事件-属性"><a href="#28-输入框文本输入实时监听事件-属性" class="headerlink" title="28. 输入框文本输入实时监听事件-属性"></a>28. 输入框文本输入实时监听事件-属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onpropertychange=&quot;handle();&quot; oninput=&quot;handle();&quot;</span><br></pre></td></tr></table></figure><h3 id="29-判断obj是否是字符串类型"><a href="#29-判断obj是否是字符串类型" class="headerlink" title="29. 判断obj是否是字符串类型"></a>29. 判断obj是否是字符串类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((typeof obj!=&apos;string&apos;)&amp;&amp; obj.constructor!=String)</span><br></pre></td></tr></table></figure><h3 id="30-trim-去除空格"><a href="#30-trim-去除空格" class="headerlink" title="30. trim() 去除空格"></a>30. <code>trim()</code> 去除空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line">return this.replace(/(^\s+)|(\s+$)/g, &quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31"><a href="#31" class="headerlink" title="31."></a>31.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">num 要产生多少个随机数</span><br><span class="line">from 产生随机数的最小值</span><br><span class="line">to 产生随机数的最大值</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">function createRandom2(num , from , to)</span><br><span class="line">&#123;</span><br><span class="line">    var arr=[];</span><br><span class="line">    var json=&#123;&#125;;</span><br><span class="line">    while(arr.length&lt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        //产生单个随机数</span><br><span class="line">        var ranNum=Math.ceil(Math.random()*(to-from))+from;</span><br><span class="line">        //通过判断json对象的索引值是否存在 来标记 是否重复</span><br><span class="line">        if(!json[ranNum])</span><br><span class="line">        &#123;</span><br><span class="line">            json[ranNum]=1;</span><br><span class="line">            arr.push(ranNum);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">alert(createRandom2(10,0,50));//生成10个从0-50之间不重复的随机数</span><br></pre></td></tr></table></figure><h3 id="32-图片懒加载—只加载可视区域图片"><a href="#32-图片懒加载—只加载可视区域图片" class="headerlink" title="32. 图片懒加载—只加载可视区域图片"></a>32. 图片懒加载—只加载可视区域图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var aImages = document.images; //获取id为SB的文档内所有的图片</span><br><span class="line">loadImg(aImages);</span><br><span class="line">window.onscroll = function() &#123; //滚动条滚动触发</span><br><span class="line">    loadImg(aImages);</span><br><span class="line">&#125;;</span><br><span class="line">//getBoundingClientRect 是图片懒加载的核心</span><br><span class="line">function loadImg(arr) &#123;</span><br><span class="line">    for(var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if(arr[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight &amp;&amp; !arr[i].isLoad) &#123;</span><br><span class="line">            arr[i].isLoad = true; //图片显示标志位</span><br><span class="line">            //arr[i].style.cssText = &quot;opacity: 0;&quot;;</span><br><span class="line">            (function(i) &#123;</span><br><span class="line">                setTimeout(function() &#123;</span><br><span class="line">                    if(arr[i].dataset) &#123; //兼容不支持data的浏览器</span><br><span class="line">                        aftLoadImg(arr[i], arr[i].dataset.imgurl);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        aftLoadImg(arr[i], arr[i].getAttribute(&quot;data-imgurl&quot;));</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[i].style.cssText = &quot;transition: 1s; opacity: 1;&quot; //相当于fadein</span><br><span class="line">                &#125;, 500)</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function aftLoadImg(obj, url) &#123;</span><br><span class="line">    var oImg = new Image();</span><br><span class="line">    oImg.onload = function() &#123;</span><br><span class="line">        obj.src = oImg.src; //下载完成后将该图片赋给目标obj目标对象</span><br><span class="line">    &#125;</span><br><span class="line">    oImg.src = url; //oImg对象先下载该图像</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-transform-left-50-top-50-居中"><a href="#33-transform-left-50-top-50-居中" class="headerlink" title="33. transform left 50% top 50% 居中"></a>33. <code>transform left 50% top 50%</code> 居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-webkit-transform: translate(-50%, -50%);</span><br><span class="line">-moz-transform: translate(-50%, -50%);</span><br><span class="line">-ms-transform: translate(-50%, -50%);</span><br><span class="line">-o-transform: translate(-50%, -50%);</span><br><span class="line">transform: translate(-50%, -50%);</span><br></pre></td></tr></table></figure><h3 id="34-input-type-number-右侧会有上下箭头"><a href="#34-input-type-number-右侧会有上下箭头" class="headerlink" title="34. input type=number 右侧会有上下箭头"></a>34. <code>input type=number</code> 右侧会有上下箭头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input::-webkit-outer-spin-button, input::-webkit-inner-spin-button&#123;-webkit-appearance: none;&#125;</span><br><span class="line">input[type=&apos;number&apos;]&#123;-moz-appearance: textfield;&#125;</span><br></pre></td></tr></table></figure><h3 id="35-iframe-加载完毕-再执行"><a href="#35-iframe-加载完毕-再执行" class="headerlink" title="35. iframe 加载完毕 再执行"></a>35. <code>iframe</code> 加载完毕 再执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function(e)&#123;    </span><br><span class="line">var iframe = document.getElementById(&quot;online_intro&quot;);      </span><br><span class="line">    if (iframe.attachEvent) &#123;</span><br><span class="line">        iframe.attachEvent(&quot;onload&quot;, function() &#123;      </span><br><span class="line">            //iframe加载完成后你需要进行的操作</span><br><span class="line">            iframe_load = true;</span><br><span class="line">            if (room_load) &#123;</span><br><span class="line">            send_room_info();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);      </span><br><span class="line">    &#125; else &#123;      </span><br><span class="line">        iframe.onload = function() &#123;      </span><br><span class="line">            //iframe加载完成后你需要进行的操作</span><br><span class="line">            iframe_load = true;  </span><br><span class="line">            if (room_load) &#123;</span><br><span class="line">            send_room_info();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="36-replace-全部替换"><a href="#36-replace-全部替换" class="headerlink" title="36. replace 全部替换"></a>36. <code>replace</code> 全部替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&quot;,&quot;,&quot;g&quot;);//g,表示全部替换。</span><br><span class="line">a.replace(reg,&quot;-&quot;);</span><br></pre></td></tr></table></figure><h3 id="37-数组去重"><a href="#37-数组去重" class="headerlink" title="37. 数组去重"></a>37. 数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function()&#123;</span><br><span class="line">    var res = [];</span><br><span class="line">    var json = &#123;&#125;;</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">        if(!json[this[i]])&#123;</span><br><span class="line">            res.push(this[i]);</span><br><span class="line">            json[this[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="38-css清除浮动的方法"><a href="#38-css清除浮动的方法" class="headerlink" title="38. css清除浮动的方法"></a>38. css清除浮动的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;clear: both;&#125;</span><br><span class="line">.clearfix: &#123;zoom: 1&#125;</span><br></pre></td></tr></table></figure><h3 id="39-弹框点击空白区域隐藏"><a href="#39-弹框点击空白区域隐藏" class="headerlink" title="39. 弹框点击空白区域隐藏"></a>39. 弹框点击空白区域隐藏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.onmousedown = function(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    ev = $(ev.target);</span><br><span class="line">    if(ev.attr(&apos;class&apos;) == &apos;alert&apos;)&#123;</span><br><span class="line">        ev.hide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40-遇到h5页面图片点击自动放大的问题"><a href="#40-遇到h5页面图片点击自动放大的问题" class="headerlink" title="40. 遇到h5页面图片点击自动放大的问题"></a>40. 遇到h5页面图片点击自动放大的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: none;</span><br></pre></td></tr></table></figure><h3 id="41-弹框点击空白区域隐藏"><a href="#41-弹框点击空白区域隐藏" class="headerlink" title="41. 弹框点击空白区域隐藏"></a>41. 弹框点击空白区域隐藏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 弹框点击空白区域隐藏</span><br><span class="line">document.ontouchend = function(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    ev = $(ev.target);</span><br><span class="line">    if(ev.attr(&apos;itemprop&apos;) == &apos;contentUrl&apos;)&#123;</span><br><span class="line">        ev.stopPropagation();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-canvas-将两张图片合并"><a href="#42-canvas-将两张图片合并" class="headerlink" title="42. canvas 将两张图片合并"></a>42. <code>canvas</code> 将两张图片合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function drawMyCanvas(code)&#123;</span><br><span class="line">        var canvas = document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">        var context = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">        var myImage = new Image();</span><br><span class="line">        myImage.src = &apos;img/background.png&apos;;</span><br><span class="line">        myImage.crossOrigin = &apos;Anonymous&apos;;</span><br><span class="line">        myImage.onload = function()&#123;</span><br><span class="line">            context.drawImage(myImage, 0, 0, 640, 1136);</span><br><span class="line">            // draw 文本</span><br><span class="line">            context.font = &quot;26px Arial&quot;;</span><br><span class="line">            context.fillStyle = &apos;#fd6265&apos;;</span><br><span class="line">            context.fillText(code, 355, 378);</span><br><span class="line"></span><br><span class="line">            var imgUri = canvas.toDataURL(&quot;image/png&quot;); // 获取生成的图片的url</span><br><span class="line">            $(&apos;#myImg&apos;).attr(&apos;src&apos;, imgUri);</span><br><span class="line">            //$(&apos;#myImg&apos;).parent().attr(&#123;&apos;href&apos;: imgUri, download: &apos;hyb_four_anni&apos;&#125;);</span><br><span class="line">            return;</span><br><span class="line">            // 生成一个a元素</span><br><span class="line">            var a = document.createElement(&apos;a&apos;);</span><br><span class="line">            // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称</span><br><span class="line">            a.download = &apos;hyb_four_anni.png&apos;;</span><br><span class="line">            // 将生成的URL设置为a.href属性</span><br><span class="line">            a.href = imgUri;</span><br><span class="line">            // 创建一个单击事件</span><br><span class="line">            var event = document.createEvent(&apos;MouseEvents&apos;);//new TouchEvent(&apos;click&apos;);</span><br><span class="line">            //event.initMouseEvent(&apos;click&apos;);</span><br><span class="line">            event.initMouseEvent(&apos;click&apos;,true,false,window,0,0,0,0,0,false,false,false,false,0,null);</span><br><span class="line">            // 触发a的单击事件</span><br><span class="line">            a.dispatchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43-上传base64图片"><a href="#43-上传base64图片" class="headerlink" title="43. 上传base64图片"></a>43. 上传base64图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">首先获取base64图片&lt;img&gt;</span><br><span class="line">/** </span><br><span class="line">    * 根据base64 内容 取得 bolb </span><br><span class="line">    * </span><br><span class="line">    * @param dataURI </span><br><span class="line">    * @returns Blob </span><br><span class="line">    */</span><br><span class="line">    function getBlobBydataURI(dataURI,type) &#123; </span><br><span class="line">        var binary = atob(dataURI.split(&apos;,&apos;)[1]); </span><br><span class="line">        var array = []; </span><br><span class="line">        for(var i = 0; i &lt; binary.length; i++) &#123; </span><br><span class="line">        array.push(binary.charCodeAt(i)); </span><br><span class="line">        &#125; </span><br><span class="line">        return new Blob([new Uint8Array(array)], &#123;type:type &#125;); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">function downloadImg()&#123;</span><br><span class="line">        //base64 转 blob </span><br><span class="line">        var $Blob= getBlobBydataURI(document.getElementsByTagName(&quot;img&quot;)[0].src,&apos;image/png&apos;); </span><br><span class="line">        var formData = new FormData(); </span><br><span class="line">        formData.append(&quot;files&quot;, $Blob ,&quot;file_&quot;+Date.parse(new Date())+&quot;.png&quot;); </span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:&apos;/api/image/upload?uid=123&apos;,</span><br><span class="line">            type:&apos;post&apos;,</span><br><span class="line">            data:formData,</span><br><span class="line">            async: true,</span><br><span class="line">            crossDomain: true,</span><br><span class="line">            contentType: false,</span><br><span class="line">            processData: false,</span><br><span class="line">            success:function(data)&#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:function(error)&#123;</span><br><span class="line">                console.log(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">        //组建XMLHttpRequest 上传文件 </span><br><span class="line">        var request = new XMLHttpRequest(); </span><br><span class="line">        //上传连接地址 </span><br><span class="line">        request.open(&quot;POST&quot;, &quot;/api/image/upload?uid=123&quot;); </span><br><span class="line">        request.onreadystatechange = function() &#123; </span><br><span class="line">            if (request.readyState == 4) </span><br><span class="line">            &#123; </span><br><span class="line">                if(request.status == 200)&#123; </span><br><span class="line">                    console.log(&quot;上传成功&quot;); </span><br><span class="line">                &#125;else&#123; </span><br><span class="line">                    console.log(&quot;上传失败,检查上传地址是否正确&quot;); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        request.send(formData); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="44-获取元素定位"><a href="#44-获取元素定位" class="headerlink" title="44. 获取元素定位"></a>44. 获取元素定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var input = document.getElementById(&apos;J_MyInput&apos;); // 根据ID取得元素对象</span><br><span class="line">var sizeObj = input.getBoundingClientRect(); // 取得元素距离窗口的绝对位置</span><br><span class="line">// 窗口的滚动偏移（垂直、水平）</span><br><span class="line">var bodyOffset = &#123;top: document.body.scrollTop, left: document.body.scrollLeft&#125;;</span><br><span class="line"> </span><br><span class="line">// 元素相对于页面的绝对位置 = 窗口滚动偏移 + 元素相对于窗口的绝对位置</span><br><span class="line">var inputOffsetTop = sizeObj.top + bodyOffset.top; // 距顶部</span><br><span class="line">var inputOffsetLeft = sizeObj.left + bodyOffset.left; // 距左侧</span><br></pre></td></tr></table></figure><h3 id="45-h5字体变细"><a href="#45-h5字体变细" class="headerlink" title="45. h5字体变细"></a>45. h5字体变细</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font-family: \\5FAE\8F6F\96C5\9ED1,Tahoma,Helvetica,Arial,\\5B8B\4F53,sans-serif;</span><br><span class="line">-moz-font-feature-settings: &quot;kern&quot;;</span><br><span class="line">-webkit-font-smoothing: antialiased;</span><br><span class="line">-moz-osx-font-smoothing: grayscale;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习</title>
      <link href="/2019/01/11/Nodejs/webpack%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/11/Nodejs/webpack%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/11/Nodejs/webpack学习/webpack.png" alt="webpack"><br>webpack是<em>静态模块打包器</em>，它有一个模块的概念，webpack将所有文件都看作是模块，将这些模块分类并配置一定的规则，按照这些规则进行处理的过程，就是webpack的工作过程。<br>webpack具体是如何工作的，在项目中该如何去使用，是这篇文章要跟大家分享的，我会将学到的内容及时分享在这里~<br>这篇文章，基于webpack 4.x版本，与webpack 3有一些不同之处，学习webpack3的也可以作为参考~<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.在安装之前，我们需要在项目根目录已经创建好package.json文件，如果没有，执行以下指令去创建：<br><figure class="highlight plain"><figcaption><span>init```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.使用npm安装webpack，终端进入到项目根目录，执行以下指令进行安装：</span><br><span class="line">```npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><p>3.创建目录，项目结构如下：<br><img src="/2019/01/11/Nodejs/webpack学习/mulu.png" alt="项目目录" style="width: 240px;"></p><blockquote><p>app：我们所有的源文件都写在app文件夹下</p><blockquote><p>main.js为webpack的入口文件（下面会讲到）<br>public为webpack打包后输出的文件夹<br>webpack.config.js为webpack配置文件（放在根目录下）</p></blockquote></blockquote><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>为了更容易去理解，先简单介绍一些webpack的配置文件webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 基本配置</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  entry: &apos;./app/main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;public&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 解释：这段代码告诉webpack，使用development模式的内置优化，以app文件夹下的main.js作为入口，以bundle.js作为输出，输出路径为根目录下的public文件夹。</span><br></pre></td></tr></table></figure><h5 id="mode：告知-webpack-使用相应模式的内置优化。"><a href="#mode：告知-webpack-使用相应模式的内置优化。" class="headerlink" title="mode：告知 webpack 使用相应模式的内置优化。"></a>mode：告知 webpack 使用相应模式的内置优化。</h5><p>官方解释是这样的：<br><img src="/2019/01/11/Nodejs/webpack学习/mode.png" alt="webpack mode" style="height: 200px;"><br>webpack 4之前是没有mode配置的。</p><h5 id="entry：指定入口文件，也可以是个数组，放入多个入口文件"><a href="#entry：指定入口文件，也可以是个数组，放入多个入口文件" class="headerlink" title="entry：指定入口文件，也可以是个数组，放入多个入口文件"></a>entry：指定入口文件，也可以是个数组，放入多个入口文件</h5><h5 id="outpub：输出，可以控制webpack如何向硬盘写入编译文件"><a href="#outpub：输出，可以控制webpack如何向硬盘写入编译文件" class="headerlink" title="outpub：输出，可以控制webpack如何向硬盘写入编译文件"></a>outpub：输出，可以控制webpack如何向硬盘写入编译文件</h5><p>接下来，我们要做的事情：</p><ol><li>使用webpack来将项目中的.less文件转换为.css文件，并将生成的.css文件输出</li><li>以app文件夹下的index.html为模板文件，输出新的.html文件，并引入.css文件</li></ol><h2 id="入口entry"><a href="#入口entry" class="headerlink" title="入口entry"></a>入口entry</h2><p>目录中的main.js是webpack的入口文件，什么是入口文件？<br>入口文件，是为了让webpack知道我们项目使用了哪些模块，以及这些模块之间的依赖关系，即作为webpack内部依赖图的开始。</p><p>要将.less文件转换为.css文件，首先先创建.less文件：<br>在/app/project_one路径下创建 <code>common.less</code> 和 <code>index.less</code> 文件。<br>common.less 文件写入共用样式；<br>index.less 文件写入index.html页面用到的样式，该文件使用 <code>@import</code> 引入 <code>common.less</code></p><p>common.less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    -ms-text-size-adjust: 100%;</span><br><span class="line">    -webkit-text-size-adjust: 100%;</span><br><span class="line">&#125;</span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">    box-sizing: inherit;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6, p, ul &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.flex&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.less</span><br><span class="line">@import &apos;common.less&apos;;</span><br><span class="line">.main&#123;</span><br><span class="line">width: calc(100% - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好我们的样式文件，接下来，需要在入口文件 <code>mian.js</code> 中引入样式文件，告诉webpack要处理的样式文件</p><p>main.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./project_one/index.less&apos;;</span><br></pre></td></tr></table></figure><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p><ul><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句。</li><li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li></ul><h2 id="输出output"><a href="#输出output" class="headerlink" title="输出output"></a>输出output</h2><p>在webpack中，配置output最低要求是，将它的值设置为一个对象，包括两个属性：<br>filename：输出的文件名称<br>path：输出的文件路径</p><p>在这里，我们这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;public&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>如果，我们的入口文件有多个，配置文件中 entry 需要配置为数组；如果想让不同的入口文件，对应不同的输出文件，怎么办呢？可以使用占位符，需要了解的可以访问<a href="https://www.webpackjs.com/configuration/output/#output-filename" target="_blank" rel="noopener">占位符</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: &apos;./app/main.js&apos;,</span><br><span class="line">      index: &apos;./app/index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;public&apos;),</span><br><span class="line">        filename: &apos;[name].bundle.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h5><ul><li>name：entry 定义的 key 值，即上面代码中的 main 和 index</li><li>hash：每次构建 webpack，都会生成唯一的 hash 值</li><li>chunkhash：打包的模块会生成唯一 hash，模块有变动，重新打包的模块 hash 会生成新的；而没有更改的模块打包生成的 hash 不变</li></ul><h2 id="模块module"><a href="#模块module" class="headerlink" title="模块module"></a>模块module</h2><p>配置文件中的 模块 用于处理项目中不同类型的模块。</p><h4 id="module-rules-module中的主要属性rules"><a href="#module-rules-module中的主要属性rules" class="headerlink" title="module.rules - module中的主要属性rules"></a>module.rules - module中的主要属性rules</h4><p>创建模块时，匹配请求的规则数组<br>每个规则又有很多属性，这里我们主要用到了 <code>test</code> 和 <code>use</code></p><ul><li>test：条件，即通过条件去匹配需要处理的文件</li><li>use：在规则条件匹配时使用，每个use指定使用一个loader，loader 用于对模块的源代码进行转换， 下面会讲到</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/, // 正则匹配 .less 结尾的文件</span><br><span class="line">                use: [</span><br><span class="line">                    &#123; loader: &apos;style-loader&apos; &#125; // 直接创建&lt;style&gt;加入到页面</span><br><span class="line">                    // &apos;style-loader&apos; 这里是简写，省略了loader</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="预处理器loader"><a href="#预处理器loader" class="headerlink" title="预处理器loader"></a>预处理器loader</h2><p>需要的 loader 有：</p><ul><li>style-loader：会在html文件中插入<style></style>，并将打包好的css放入style中</li><li>css-loader：加载 css 文件</li><li>less-loader：将 .less 文件转换为 .css 文件</li></ul><p>使用这些loader，首先要安装这些loader，nodejs中使用 npm 安装：</p><p><code>npm install style-loader css-loader less-loader less --save-dev</code></p><p>来看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: /\.less$/,</span><br><span class="line">use: [</span><br><span class="line">// 这里都是简写</span><br><span class="line">&apos;style-loader&apos;,</span><br><span class="line">&apos;css-loader&apos;,</span><br><span class="line">&apos;less-loader&apos;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意：值得注意的是，loader 是有加载顺序的，loader 的加载顺序是从后向前加载的，即：先加载less-loader 将 .less 文件转换为.css文件，其次加载 css-loader 处理.css文件，最后加载style-loader ，将css写入html。</p><h2 id="插件plugins"><a href="#插件plugins" class="headerlink" title="插件plugins"></a>插件plugins</h2><p>插件，是用来扩展webpack功能的，它们会在整个构建过程中生效，执行相关的任务。<br>很多时候，Loaders 和 Plugins 很容易被搞混，其实它们是完全不同的东西，loaders 是在打包构建工程中用来处理源文件的，一次处理一个；插件不会直接操作单个文件，而直接对整个构建过程起作用。</p><p>这里，我们介绍 html-webpack-plugin 插件，它的作用有哪些呢？</p><ol><li>为 html 文件引入外部资源</li><li>可以生成html入口文件，即.html文件；配置N个<code>html-webpack-plugin</code>可以生成N个页面</li></ol><p>首先，通过<code>npm</code>安装<code>html-webpack-plugin</code>插件：<br><code>npm install html-webpack-plugin --save-dev</code></p><p>使用：</p><ol><li>webpack 配置文件顶部require引入</li><li>plugins 中创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// plugins 与 entry、output同级</span><br><span class="line">plugins: [        </span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: &apos;index.html&apos;,</span><br><span class="line">            template: &apos;./app/index.html&apos;,</span><br><span class="line">            inject: &apos;body&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解释一下：</p><ul><li>filename：生成的文件名称</li><li>template：本地模板文件位置，生成的.html文件以指定的文件为模板</li><li>inject: 引入的外部资源，插入到html中的位置</li></ul><p>先附上完成配置文件代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.resolve(__dirname, &apos;app/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;public&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &apos;style-loader&apos;, // 直接创建&lt;style&gt;加入到页面</span><br><span class="line">                    &apos;css-loader&apos;,</span><br><span class="line">                    &apos;less-loader&apos;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: &apos;index.html&apos;,</span><br><span class="line">            template: &apos;./app/index.html&apos;,</span><br><span class="line">            inject: &apos;body&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    mode: &apos;development&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们最初布置的任务就算完成了，接下来只剩下打包了~</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包很简单，只需要在package.json中的scripts下添加如下代码：<br><code>&quot;start&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-resasons&quot;</code><br>接着在终端，<code>cd</code>到项目根目录，运行<code>npm start</code>就开始运行webpack打包了~</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发总结 - Xcode常见错误</title>
      <link href="/2019/01/07/iOS/iOS%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/07/iOS/iOS%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>iOS开发中，出现各种错误，针对这些错误，这篇文章给出了正确的解决方案，并总结下来帮助遇到困难的朋友。文章将由<a href="https://www.jianshu.com/u/46ae5ab6420e" target="_blank" rel="noopener">夜雨寒</a>维护并持续更新，有不对的地方，可以在下面评论区提出来~<br><a id="more"></a></p></blockquote><h4 id="1-查询异常"><a href="#1-查询异常" class="headerlink" title="1.查询异常"></a>1.查询异常</h4><ul><li><p><code>&quot;directory not found for option &#39;-L/…&quot;</code></p><blockquote><p>表示查询 Library 的时候出现异常<br> 解决方法：<br> 依次 Project -&gt; targets -&gt; Build Setting -&gt; Library Search Paths删除里面的路径</p></blockquote></li><li><p><code>&quot;directory not found for option &#39;-F/...&quot;</code></p><blockquote><p>表示查询 Framework 的时候出现异常<br> 解决方法：<br> 依次 Project -&gt; targets -&gt; Build Setting -&gt; Framework Search Paths删除里面的路径</p></blockquote></li></ul><h4 id="2-library-not-found-for-lstdc-6-0-9"><a href="#2-library-not-found-for-lstdc-6-0-9" class="headerlink" title="2.library not found for -lstdc++.6.0.9"></a>2.library not found for -lstdc++.6.0.9</h4><blockquote><p>更新Xcode 10.1之后，项目运行报这个错误：<br>library not found for -lstdc++.6.0.9<br>意思是找不到 libstdc++.6.0.9，由于iOS12移除了libstdc++.6.0.9，取消了6.0.9的支持</p></blockquote><p>解决办法：</p><ol><li>打开Build Phases -&gt; Link Binary With Libraries，删除libstdc++.6.0.9依赖，如果项目中有用到c++6.0.9的，可以添加Libc++.tdb；<br>如果依赖c++6.0.9的SDK是第三方SDK等待第三方更新解决</li><li>在Build Phases -&gt; Build Settings 找到Other Linker Flags，将里面的-l “stdc++.6.0.9”删除</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp与Grunt</title>
      <link href="/2017/09/20/Nodejs/Gulp%E4%B8%8EGrunt/"/>
      <url>/2017/09/20/Nodejs/Gulp%E4%B8%8EGrunt/</url>
      
        <content type="html"><![CDATA[<p>前段时间做个项目，前期顺风顺水，慢慢随着各种需求插入到项目中来，包括后期项目的一些修改，代码冗余度越来越高，页面访问速度也受到一些影响，尤其是对某个功能的修改，可能需要找很久，个人表示很痛苦呀 -_-!<br>因此决定跳出来去找寻可以不再这么痛苦下去的技术，于是找到了它们！<br><a id="more"></a></p><p>本文主要来介绍 Webpack 和 Gulp 以及 Grunt，它们之间有什么区别？它们如何使用？以及它们是如何为我们项目开发提高效率的？<br>以下是最近一段时间研究的一些心得体会，拿出来跟大家分享一下~</p><h3 id="1-Gulp"><a href="#1-Gulp" class="headerlink" title="1. Gulp"></a>1. Gulp</h3><blockquote><p>gulp 是基于 Nodejs 的自动任务运行器，能自动化的完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。</p></blockquote><p>通俗来讲，gulp 就是一个处理项目文件的工具，通过 gulp 建立一些任务，当我们对相应文件进行修改之后，会自动触发这些任务，自动的对文件进行了处理。不用我们手动的、反复的去处理这些文件，大大提高了我们的工作效率。</p><p>举个栗子：<br>现在已经开始用 less 来写样式（less 的优点很多，写起来要比 css 快很多，在此不多说，盆友们可以上网了解 less），在 html 使用这些样式，需要用一些工具将. less 文件转换为. css 文件，如果用 Sublime 敲代码的盆友可能知道它有插件自动生成 css，但是. less 和生成的. css 文件在同一目录下。</p><p><img src="//upload-images.jianshu.io/upload_images/7147355-9af5e6b5b6abb093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>目录. png 这只是文件比较少的情况，如果文件比较多呢？是不是也是一件很头疼的事情…<br>下面，上代码带你用 gulp 解决令人头疼的问题 ^ _ ^<br>前提我们已经创建好一个 nodejs 项目，这里我们安装两个插件: gulp 和 gulp-less(编译 less 文件)<br><code>npm install gulp --save-dev</code><br><code>npm install gulp-less --save-dev</code></p><blockquote><p>新建 gulpfile.js 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 说明：gulpfile.js是gulp项目的配置文件，放项目根目录即可。</span><br><span class="line">// 导入工具包</span><br><span class="line">var gulp = require(&apos;gulp&apos;), </span><br><span class="line">    less = require(&apos;gulp-less&apos;);</span><br><span class="line"></span><br><span class="line">// 定义一个testLess任务（自定义任务名称）</span><br><span class="line">gulp.task(&apos;testLess&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;public/stylesheets/style.less&apos;) //该任务针对的文件</span><br><span class="line">        .pipe(less()) //该任务调用的模块</span><br><span class="line">        .pipe(gulp.dest(&apos;public/css&apos;)); //将会在public/css下生成style.css</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，我们只需要在命令行输入<code>gulp testLess</code>我们就可以在 public/css 下看到生成的 style.css 文件了<br>but 这显然是我们手动来生成的，我们需要的是让它自动生成，那好吧，现在我们需要一个东西能够来监听 less 文件的修改，然后自动去执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;testWatch&apos;, function () &#123;</span><br><span class="line">    gulp.watch(&apos;public/stylesheets/*.less&apos;, [&apos;testLess&apos;]); //当所有less文件发生改变时，调用testLess任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了，现在我们运行<code>gulp testWatch</code>当修改了 less 文件保存，会看到 css 文件也跟着变了 ^ _ ^<br>补充一点，我们在一个项目里使用 gulp 的时候，我们想启动项目，就自动启动了 testWatch，而不是启动项目之后，我们还要手动启动 testWatch，那么，加上下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;default&apos;,[&apos;testWatch&apos;]); // 指定gulp默认启动任务</span><br></pre></td></tr></table></figure><h3 id="2-Grunt"><a href="#2-Grunt" class="headerlink" title="2. Grunt"></a>2. Grunt</h3><blockquote><p>Grunt 基于 Node.js ，用 JS 开发，这样就可以借助 Node.js 实现跨系统跨平台的桌面端的操作，例如文件操作等等。此外，Grunt 以及它的插件们，都作为一个 包 ，可以用 NPM 安装进行管理。</p></blockquote><p>Grunt 依赖 Node.js 所以在安装之前确保你安装了 Node.js。然后开始安装 Grunt。<br>Grunt 可以帮助我们减少很多的工作量，比如：检查每个 JS 文件语法、合并两个 JS 文件、将合并后的 JS 文件压缩、将 SCSS 文件编译等，包括我们上面提到的试用 gulp 将. less 文件转换为. css 文件，grunt 也是可以实现的，下面我们用 grunt 实现 gulp 的转换 less 的功能：</p><p>和 gulp 一样，首先我们先安装 grunt 以及 grunt-contrib-less<br><code>npm install grunt --save-dev</code><br><code>npm install grunt-contrib-less --save-dev</code></p><blockquote><p>新建 Gruntfile.js 文件</p></blockquote><p>使用 grunt，主要有三块代码：任务配置代码、插件加载代码、任务注册代码。<br>任务配置代码就是调用插件配置一下要执行的任务和实现的功能，插件加载代码就是把需要用到的插件加载进来，任务注册代码就是注册一个 task，里面包含刚在前面编写的任务配置代码。<br>需要注意的是，grunt 的配置代码放到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(grunt) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>里面，没有为什么…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 任务配置代码</span><br><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class="line">    //less插件配置</span><br><span class="line">    less: &#123;</span><br><span class="line">        main: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">            compress: false,</span><br><span class="line">            yuicompress: false</span><br><span class="line">        &#125;,</span><br><span class="line">        files: &#123;</span><br><span class="line">            &apos;./public/css/global.css&apos;: &apos;./public/less/*.less&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// pkg 功能是读取 package.json 文件，并把里面的信息获取出来，方便在后面任务中应用</span><br><span class="line"></span><br><span class="line">// 2\. 插件加载代码</span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;);</span><br><span class="line"></span><br><span class="line">// 3\. 任务注册代码</span><br><span class="line">grunt.registerTask(&apos;lessjs&apos;, [&apos;less&apos;]);</span><br></pre></td></tr></table></figure><p>到这一步，我们已经做好 grunt 配置文件了, 控制台输入<code>grunt lessjs</code>即可实现同 gulp 一样的效果。<br>同样的，这一样使我们手动生成的，grunt 能像 gulp 一样自动为我们生成吗？答案是肯定的，grunt 同样也有 watch。<br>首先安装插件 grunt-contrib-watch<br><code>npm install grunt-contrib-watch --save-dev</code><br>在任务配置代码添加一个 watch 任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    lesses: &#123;</span><br><span class="line">            files: [&apos;./public/less/*.less&apos;],</span><br><span class="line">        tasks: [&apos;less&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要加载插件代码，任务注册代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);</span><br><span class="line">grunt.registerTask(&apos;default&apos;, [&apos;less&apos;, &apos;watch&apos;]);</span><br></pre></td></tr></table></figure><h3 id="3-grunt-与-gulp-区别"><a href="#3-grunt-与-gulp-区别" class="headerlink" title="3. grunt 与 gulp 区别"></a>3. grunt 与 gulp 区别</h3><p>上面的学习，我们知道 grunt 和 gulp 能实现同样的功能，那么它们有什么区别？分别在什么场景下使用呢？<br>在我看来，其实 grunt 和 gulp 两个东西的功能是一样的，只不过是任务配置 JS 的语法不同，Gulp 配置文件的写法更加通俗易懂，上手更快。但是 Gulp 的插件感觉不如 Grunt，只能满足基本的工作需要；而 Grunt 官方提供了一些常见的插件，满足大部分日常工作，而且可靠值得信赖，而 Gulp 好像没有太多官方出品，各种插件不太规范。<br>至于在什么场景下使用哪个？这个看个人需要吧，grunt 远远不止上面写的那么简单，如果 gulp 能满足平时工作需要，可以使用 gulp。<br>总之，用网友的话说，Grunt 和 Gulp 就像 iPhone 与 Android 一样，一个质量高学习难一点，一个学起来简单但是有点那个，你懂得。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> Gulp-Grunt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 模块化编程-require.js 的用法</title>
      <link href="/2017/08/28/Javascript/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%EF%BC%9Arequire.js%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2017/08/28/Javascript/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%EF%BC%9Arequire.js%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。<br>但是，Javascript不是一种模块化编程语言，它不支持类(class)，更别提模块了，本文将使用require.js实现“JavaScript模块化编程”。<br><a id="more"></a></p><p><a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>是一个非常流行的库。</p><p><img src="http://image.beekka.com/blog/201211/bg2012110702.jpg" alt=""></p><p><strong>一、为什么要用require.js？</strong></p><p>我们一般都习惯将Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，逻辑越来越复杂，一个文件不够了，必须分成多个文件，依次加载。那就出现了下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这段代码依次加载多个js文件。</p><p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p><p>require.js的诞生，就是为了解决这两个问题：</p><blockquote><p><img src="http://image.beekka.com/blog/201211/bg2012110701.png" alt=""></p><p>（1）实现js文件的异步加载，避免网页失去响应；</p><p>（2）管理模块之间的依赖性，便于代码的编写和维护。</p></blockquote><p><strong>二、require.js的加载</strong></p><p>使用require.js的第一步，是先去官方网站<a href="http://requirejs.org/docs/download.html" target="_blank" rel="noopener">下载</a>最新版本。</p><p>下载后，假定把它放在js子目录下面，就可以加载了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载这个文件，可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p><p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p><p><strong>三、主模块的写法</strong></p><p>上面的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。</p><p>下面就来看，怎么写main.js。</p><p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p><blockquote><p>// main.js</p><p>alert(“加载成功！”);</p></blockquote><p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line"></span><br><span class="line">// some code here</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p><p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p><p>下面，我们看一个实际的例子。</p><p>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　// some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p><p><strong>四、模块的加载</strong></p><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p><p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line"> 　　paths: &#123;</span><br><span class="line"> 　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line"> 　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line"> 　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line"> </span><br><span class="line"> 　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　 paths: &#123;</span><br><span class="line"> &quot;jquery&quot;: &quot;**lib/**jquery.min&quot;,</span><br><span class="line"> &quot;underscore&quot;: &quot;**lib/**underscore.min&quot;,</span><br><span class="line"> &quot;backbone&quot;: &quot;**lib/**backbone.min&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另一种则是直接改变基目录（baseUrl）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line"> 　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line"> 　　　　paths: &#123;</span><br><span class="line"> 　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line"> 　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　 &quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line"> </span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line"> 　　　 &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>五、AMD模块的写法</strong></p><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p><p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p><p>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>加载方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js </span><br><span class="line">require([&apos;math&apos;], function (math)&#123; </span><br><span class="line"> 　　alert(math.add(1,1));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;myLib&apos;], function(myLib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p><p><strong>六、加载非规范的模块</strong></p><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p><p>回答是可以的。</p><p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p><p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line">　　　　　　&apos;underscore&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;_&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line"></span><br><span class="line">　　　　　　&apos;backbone&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;Backbone&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p><p>比如，jQuery的插件可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line"></span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line"></span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> require.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp-项目构建利器</title>
      <link href="/2017/08/17/Nodejs/gulp-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%88%A9%E5%99%A8/"/>
      <url>/2017/08/17/Nodejs/gulp-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%88%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>gulp是什么？</p><p>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。<br><a id="more"></a></p><p>gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。</p><p>gulp基于Nodejs，因此我们一切操作在Nodejs项目中操作。</p><blockquote><p>gulp 之 gulp-less</p></blockquote><p>使用gulp-less插件将less文件编译成css<br>项目根目录创建gulpfile.js，gulpfile.js是gulp项目的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//导入工具包 require(&apos;node_modules里对应模块&apos;)</span><br><span class="line"></span><br><span class="line">vargulp =require(&apos;gulp&apos;),//本地安装gulp所用到的地方</span><br><span class="line"></span><br><span class="line">less=require(&apos;gulp-less&apos;);</span><br><span class="line"></span><br><span class="line">//定义一个testLess任务（自定义任务名称）</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;testLess&apos;,function() &#123;</span><br><span class="line"></span><br><span class="line">    gulp.src(&apos;public/stylesheets/style.less&apos;)//该任务针对的文件</span><br><span class="line"></span><br><span class="line">    .pipe(less())//该任务调用的模块</span><br><span class="line"></span><br><span class="line">    .pipe(gulp.dest(&apos;public&apos;));//将会在src/css下生成index.css</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;,[&apos;testLess&apos;]);//定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务</span><br></pre></td></tr></table></figure><blockquote><p>gulp 之 gulp-htmlmin</p></blockquote><p>使用gulp-htmlmin压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;testHtmlmin&apos;, function () &#123;</span><br><span class="line">    var options = &#123;</span><br><span class="line">        removeComments: true,//清除HTML注释</span><br><span class="line">        collapseWhitespace: true,//压缩HTML</span><br><span class="line">        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;</span><br><span class="line">        minifyJS: true,//压缩页面JS</span><br><span class="line">        minifyCSS: true//压缩页面CSS</span><br><span class="line">    &#125;;</span><br><span class="line">    gulp.src(&apos;views/*.html&apos;)</span><br><span class="line">        .pipe(htmlmin(options))</span><br><span class="line">        .pipe(gulp.dest(&apos;public/html&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>gulp 之 gulp-concat</p></blockquote><p>使用gulp-concat合并javascript文件，减少网络请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;testConcat&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;public/javascripts/*.js&apos;)</span><br><span class="line">        .pipe(concat(&apos;all.js&apos;))//合并后的文件名</span><br><span class="line">        .pipe(gulp.dest(&apos;public&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>gulp 之 gulp-clean-css</p></blockquote><p>使用gulp-clean-css压缩css文件，减小文件大小，并给引用url添加版本号避免缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 基本使用</span><br><span class="line">gulp.task(&apos;testCssmin&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;public/stylesheets/*.css&apos;)</span><br><span class="line">        .pipe(cssmin())</span><br><span class="line">        .pipe(gulp.dest(&apos;public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 其他参数使用</span><br><span class="line">gulp.task(&apos;testCssmin&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;public/stylesheets/*.css&apos;)</span><br><span class="line">        .pipe(cssmin(&#123;</span><br><span class="line">            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]</span><br><span class="line">            compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式]</span><br><span class="line">            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]</span><br><span class="line">            keepSpecialComments: &apos;*&apos;</span><br><span class="line">            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 给css文件里引用url加版本号（根据引用文件的md5生产版本号）- 避免缓存</span><br><span class="line">// 确保已本地安装gulp-make-css-url-version [cnpm install gulp-make-css-url-version --save-dev]</span><br><span class="line">gulp.task(&apos;testCssmin&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;public/stylesheets/*.css&apos;)</span><br><span class="line">        .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5）</span><br><span class="line">        .pipe(cssmin())</span><br><span class="line">        .pipe(gulp.dest(&apos;public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 若想保留注释，这样注释即可：</span><br><span class="line">/*!</span><br><span class="line">   Important comments included in minified output.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript插件 - 计时器</title>
      <link href="/2017/08/02/Javascript/JavaScript%E6%8F%92%E4%BB%B6-%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
      <url>/2017/08/02/Javascript/JavaScript%E6%8F%92%E4%BB%B6-%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>js封装的一个计时器的插件，start()开始计时，end()结束计时，返回一次计时的时间。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;(function(undefined)&#123;</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var _global, timer, time;</span><br><span class="line">var plugin = &#123;</span><br><span class="line">start: function()&#123;</span><br><span class="line">time = 0;</span><br><span class="line">timer = setInterval(function()&#123;</span><br><span class="line"> time ++;</span><br><span class="line"> console.log(time)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;,</span><br><span class="line">end: function()&#123;</span><br><span class="line">clearInterval(timer);</span><br><span class="line">return time;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 最后将插件对象暴露给全局对象</span><br><span class="line">    _global = (function()&#123; return this || (0, eval)(&apos;this&apos;); &#125;());</span><br><span class="line">    if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = plugin;</span><br><span class="line">    &#125; else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(function()&#123;return plugin;&#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        !(&apos;plugin&apos; in _global) &amp;&amp; (_global.plugin = plugin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js计时器 </tag>
            
            <tag> js插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间管理-四象限法则</title>
      <link href="/2017/08/02/Article/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95%E5%88%99/"/>
      <url>/2017/08/02/Article/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>四象限法则，就是我们应有重点地把主要的精力和时间集中地放在处理那些重要但不紧急的工作上的时间管理理论的重要观念。</p><p>在我们的日常生活工作中，总会有一些重要或不重要的事情临时的安插在我们已作好安排的生活或工作当中，从而使我们不得不分离一些重心在这些事情上面，影响我们当下的工作。我们能不能做到不受其他工作的影响，专心去完成当下的工作呢？答案是肯定的。</p><a id="more"></a><blockquote><p>一、什么是四象限法则</p></blockquote><p>首先，四象限法则是一个时间管理理论；该理论最重要的内容就是把事情按照<strong>重要</strong>和<strong>紧急程度</strong>划分为四个象限：重要而且紧急、重要但不紧急、不重要但紧急、不重要而且不紧急。</p><div class="image-package"><img src="//upload-images.jianshu.io/upload_images/7147355-36eea69dd872bdfe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><br><div class="image-caption">四象限法则</div><p></p></div><p></p><blockquote><p>二、四象限界限的划分</p></blockquote><p>如果把事情按照紧急、不紧急、重要、不重要的排列组合分成四个象限，有利于我们深刻的认识时间及有效的管理时间。如何评估一件事情的重要和紧急程度以及如何对这件事情进行划分呢？</p><p>如何评价一件事情的重要程度，这不仅要结合实际去判断，还要<strong>按照职业价值观来判断</strong>，而紧急程度则是由时间底限来确定的。</p><p>面对手中的一堆事情，我们该如何划分呢？</p><blockquote><p>1）“轻重”区分，给所有事项以职业价值观为标准区分为是重要还是不重要；</p><p>2）“缓急”区分，给所有事项以时间截止期限为标准区分是紧急还是不紧急。</p></blockquote><p>简单的两步，我们就可以将所有事情划分到四象限中去。接下来就是如何去处理四象限中的这些事情！</p><blockquote><p>三、四象限事务处理</p></blockquote><p>根据四象限，我们可以很直观的看出来事情的优先级，在我们平时工作当中，应该把主要精力放在重要的事情，尤其是那些重要且紧急的事项；对于重要不紧急或紧急不重要的事情，我们应该优先去做重要的事情，但也就事而论吧，比如对于工作，我个人还是比较偏向于优先去完成比较紧急的事项，对于生活，不重要的事情我们完全可以不做；对于既不重要又不紧急的事情，按部就班去做就行！</p><div class="image-package"><img src="//upload-images.jianshu.io/upload_images/7147355-b2330f40ca871928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><br><div class="image-caption">四象限事务处理</div><p></p></div><p></p><blockquote><p>（1）第一象限：立即行动</p></blockquote><p>这个象限包含非常重要且非常急迫的事情，这些事情无法回避不可拖延，必须优先处理，我们生活工作中的压力就主要来源于第一象限的任务，而第一象限的任务多数是来自于第二象限中没有被很好处理的事务。</p><p>比如，第二象限中重要且并不是很紧迫的事务，由于我们没有分解任务，没有计划的去处理这些事务，随着时间推移，紧迫程度逐步提高，进而过渡为重要且紧迫的事务。</p><blockquote><p>（2）第二象限：计划执行</p></blockquote><p>这个象限包含重要且不紧迫的事情，未雨绸缪，我们应该结合实际情况，拆分任务，根据任务轻重制定计划，按部就班去持续推进，避免进入第一象限。</p><blockquote><p>（3）第三象限：转交任务</p></blockquote><p>这部分的任务带有一定欺骗性，不同人对待事物看法不同，同样其重要程度也不同，比如有些事物对于我们并不能算作是重要的，而只是因为其比较紧迫，促使我们以为很重要，就会占用我们很多宝贵的时间。</p><p>而这部分任务表现在工作当中，往往是我们会把不属于我们的任务揽在自己身上，当他们把你当作自己猴子的收容所，收的越多，他们给的就越多，这时我们只顾照料别人的猴子，没精力照顾自己的猴子，我们应该避免这种情况，适时把任务转交出去，或着不再收容别人的猴子。</p><blockquote><p>（4）第四象限：尽量不！要！做！</p></blockquote><p>不重要且不紧迫的事情，工作中当然是少之又少的，但偶尔也不可避免，对待这些事情，尽量就不！要！做！</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.0项目研究（一）</title>
      <link href="/2017/07/11/Vue/Vue2.0%E9%A1%B9%E7%9B%AE%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/07/11/Vue/Vue2.0%E9%A1%B9%E7%9B%AE%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>搞懂一门新的技术、新的编程语言，除了研究官方文档，我们还可以研究猿友们开源的项目进行学习、进步。<br>今天来记录一下这段时间研究的一个开源项目的成果。<br><a id="more"></a></p><p>项目地址：<a href="https://github.com/putianxi/putianxi.github.io" target="_blank" rel="noopener">https://github.com/putianxi/putianxi.github.io</a><br>项目简介：目的是直观列出全国的莆田系医院</p><h3 id="index-html-文件"><a href="#index-html-文件" class="headerlink" title="index.html 文件"></a>index.html 文件</h3><p>首先，来看一下项目index.html文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;app-header&gt;&lt;/app-header&gt;</span><br><span class="line"></span><br><span class="line">    &lt;app-layout&gt;</span><br><span class="line">        &lt;app-content slot=&quot;app-content&quot;&gt;&lt;/app-content&gt;</span><br><span class="line">        &lt;app-sidebar slot=&quot;app-sidebar&quot;&gt;&lt;/app-sidebar&gt;</span><br><span class="line">    &lt;/app-layout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;app-footer&gt;&lt;/app-footer&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;dist/build.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>主要由三部分组成，分别是网站头部<code>&lt;app-header&gt;</code>、中间部分<code>&lt;app-layout&gt;</code>和网站底部<code>&lt;app-footer&gt;</code>。<br>头部和底部不用多说了，着重研究中间部分。<br><code>&lt;app-layout&gt;</code>又分为<code>&lt;app-content&gt;</code>和<code>&lt;app-sidebar&gt;</code>两部分构成，index.html先分析到这里，接下来我们先去看看main.js程序入口。</p><h3 id="main-js-文件"><a href="#main-js-文件" class="headerlink" title="main.js 文件"></a>main.js 文件</h3><p>通过查看webpack.config.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/main.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.js作为程序入口，附上一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueResource from &apos;vue-resource&apos;</span><br><span class="line">import AppHeader from &apos;./uilayout/AppHeader.vue&apos;</span><br><span class="line">import AppLayout from &apos;./uilayout/AppLayout.vue&apos;</span><br><span class="line">import AppContent from &apos;./uilayout/AppContent.vue&apos;</span><br><span class="line">import AppSidebar from &apos;./uilayout/AppSidebar.vue&apos;</span><br><span class="line">import AppFooter from &apos;./uilayout/AppFooter.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;body&apos;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        AppHeader, AppLayout, AppContent, AppSidebar, AppFooter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>作者main.js文件很简便，引入各个模块的模板文件*.vue。<br>通过<code>el: &#39;body&#39;</code>将模板渲染到index.html<code>body</code>中，<code>components</code>中创建五个模板，对应index.html中的三个部分<br><code>AppContent</code>为高德地图模板，我们暂时不作研究；<br>主要研究<code>AppSidebar</code>，右侧医院列表模板。</p><h3 id="AppSidebar-vue-文件"><a href="#AppSidebar-vue-文件" class="headerlink" title="AppSidebar.vue 文件"></a>AppSidebar.vue 文件</h3><p>一个正规的.vue文件一般分为三个部分，分别是<code>&lt;template&gt;&lt;/template&gt;</code>、<code>&lt;script&gt;&lt;/script&gt;</code>、<code>&lt;style&gt;&lt;/style&gt;</code>，html代码写在template中，js代码写在script中，还有css样式写在style中，这三个部分构成完整的.vue模板，下面我们一步步来分析：</p><h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;area-select-box&gt;&lt;/area-select-box&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;totalPage&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;hospital-box v-for=&quot;hospital in hospital_show_list&quot;</span><br><span class="line">                      :hospital-info=&quot;hospital&quot;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/hospital-box &gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;columns is-mobile card-pagination&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">                &lt;a class=&quot;button&quot;</span><br><span class="line">                   :class=&quot; &#123;&apos;is-disabled&apos; : currentPage === 1 &#125;&quot;</span><br><span class="line">                   @click=&quot;updatePageList(&apos;prev&apos;)&quot;</span><br><span class="line">                &gt;</span><br><span class="line">                    上一页</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">                &lt;h2 class=&quot;pagination-title&quot;&gt;&#123;&#123; currentPage &#125;&#125; / &#123;&#123; totalPage &#125;&#125; &lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">                &lt;a class=&quot;button is-info is-pulled-right&quot;</span><br><span class="line">                   :class=&quot; &#123;&apos;is-disabled&apos; : currentPage === totalPage &#125;&quot; </span><br><span class="line">                   @click=&quot;updatePageList(&apos;next&apos;)&quot;</span><br><span class="line">                &gt;</span><br><span class="line">                    下一页</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-else class=&quot;safe-area&quot;&gt;</span><br><span class="line">        &lt;h4&gt;</span><br><span class="line">            &lt;span class=&quot;icon&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/span&gt;此地区暂时安全</span><br><span class="line">        &lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;area-select-box&gt;&lt;/area-select-box&gt;</code>是一个小的模板，网站上面的下拉列表；还有<code>&lt;hospital-box&gt;&lt;/hospital-box&gt;</code>也是一个小的模板，作为医院列表的一个小块儿；简单浏览一遍，我们不难发现，Vue页面由很多小的模板组成，而小模板的逻辑都写在它们自己的模板中。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.0 （一）</title>
      <link href="/2017/06/21/Vue/Vue%202.0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/06/21/Vue/Vue%202.0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>项目搭建不做赘述，可以参考[Vue2.0 新手完全填坑攻略——从环境搭建到发布][1]<br>我们项目用的是：vue2.0 + vue-cli + webpack + vue-router2.0 + vue-resource1.3.4<br><a id="more"></a></p><h3 id="简单介绍目录结构"><a href="#简单介绍目录结构" class="headerlink" title="简单介绍目录结构"></a>简单介绍目录结构</h3><p><code>node_modules</code> 是项目中安装的依赖模块<br><code>App.vue</code> App.vue组件<br><code>main.js</code> 入口文件<br><code>.babelrc</code> babel编译参数，vue开发需要babel编译<br><code>index.html</code> 主页<br><code>package.json</code> 项目文件，记载着一些命令和依赖还有简要的项目描述信息</p><p>其中package.json 文件是项目配置文件，其中3个节点我们注意一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies：项目发布时的依赖</span><br><span class="line">devDependencies：项目开发时的依赖</span><br><span class="line">scripts：编译项目的一些命令</span><br></pre></td></tr></table></figure></p><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><p>这是一个标准的vue组件，包含三个部分，一个是模板，一个是script，一个是样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    // ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // ... </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。下面是个基本例子：</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span><br><span class="line">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;!-- 路由出口 --&gt;</span><br><span class="line">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 首先导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line">// 1. 定义（路由）组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; &#125;</span><br><span class="line">const Bar = &#123; template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/foo&apos;, component: Foo &#125;,</span><br><span class="line">  &#123; path: &apos;/bar&apos;, component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>需要注意的是，当<code>&lt;router-link&gt;</code>对应的路由匹配成功，将自动设置class属性值<code>.router-link-active</code>，成高亮状态。</p><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>像 /user/foo 和 /user/bar 都将映射到相同的路由。<br>路由参数使用冒号标记。当匹配到一个路由时，参数值会被设置到<code>this.$route.params</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模式                            匹配路径          </span><br><span class="line">/user/:username                 /user/evan                  </span><br><span class="line">/user/:username/post/:post_id   /user/evan/post/123</span><br><span class="line"></span><br><span class="line">$route.params</span><br><span class="line">&#123; username: &apos;evan&apos; &#125;</span><br><span class="line">&#123; username: &apos;evan&apos;, post_id: 123&#125;</span><br></pre></td></tr></table></figure><p>另外，$route.query 可设置获取 URL 中的参数</p><h4 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h4><p>从/user/foo 导航到 /user/bar , 原来的组件实例会被复用，这样更高效，不过也意味着组件的生命周期钩子不会再被调用。如果想让程序响应，该怎么办？<br>是问题就有解决的办法：可以简单的watch（监测变化）$route对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">        // 。。。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript立即执行函数 (function(){...})(jQuery)</title>
      <link href="/2017/06/06/Javascript/JavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2017/06/06/Javascript/JavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天意外发掘JavaScript中一个不广为人知，且超实用的函数–立即执行函数，这个函数被广泛应用于各类插件js中，通常它的写法是(function(){…})()包住业务代码，使用jQuery时比较常见。<br><a id="more"></a></p><h4 id="首先，说明一下这样写法有什么作用？"><a href="#首先，说明一下这样写法有什么作用？" class="headerlink" title="首先，说明一下这样写法有什么作用？"></a>首先，说明一下这样写法有什么作用？</h4><p>因为javascript中没有私有作用域的概念，如果在某个项目开发中涉及多人配合开发，那么你在全局或局部作用域中声明的一些变量，可能会被其他人声明的同名变量覆盖。<br>根据javascript函数作用域链的特性，可以使用这种技术模仿一个私有作用域，用匿名函数作为一个“容易”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以是(function(){…})()就避免了内部变量和外部变量发生冲突。</p><h4 id="函数声明、函数表达式、匿名函数"><a href="#函数声明、函数表达式、匿名函数" class="headerlink" title="函数声明、函数表达式、匿名函数"></a>函数声明、函数表达式、匿名函数</h4><p>理解一些函数的基本概念：<br>（1）函数声明：使用function声明函数，指定一个函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fnName() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>（2）函数表达式：使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fnName = function() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>（3）匿名函数：使用function关键字声明一个函数，但未给函数命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>注：匿名函数属于函数表达式</p><h4 id="函数声明和函数表达式不同之处"><a href="#函数声明和函数表达式不同之处" class="headerlink" title="函数声明和函数表达式不同之处"></a>函数声明和函数表达式不同之处</h4><p>介绍一下函数声明和函数表达式不同之处，你会知道原来javascript还可以这么写。<br>函数声明和函数表达式不同之处在于，<br>（1）Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。<br>（2）函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。</p><p>附上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fnName(); // 函数调用</span><br><span class="line">function fnName() &#123; ... &#125; // 函数声明</span><br><span class="line">// 这种写法是没有毛病的，因为函数声明被提升了，所以函数调用可在函数声明之前</span><br><span class="line"></span><br><span class="line">fnName(); // 函数调用</span><br><span class="line">var fnName = function() &#123; ... &#125; // 函数表达式</span><br><span class="line">// 报错，变量fnName还未保存为对函数的引用，函数调用必须在函数表达式之后</span><br></pre></td></tr></table></figure></p><p>在【函数表达式】后面加括号就能立即调用，下面是立即执行函数的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// （）、！、+、-、=等运算符，都可以将函数声明转换为表达式，在后面加括号，可以立即执行函数</span><br><span class="line"></span><br><span class="line">=！+-function(a)&#123;</span><br><span class="line">    console.log(a); // 输出123</span><br><span class="line">&#125;(123)</span><br><span class="line"></span><br><span class="line">(function(a)&#123;</span><br><span class="line">    console.log(a); // 输出123</span><br><span class="line">&#125;)(123);</span><br><span class="line">// 加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</span><br></pre></td></tr></table></figure></p><p>拓展：JQuery使用的就是这种方法，将JQuery代码包裹在(function(window,undefined){ …jquery代码… }(window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 拓展jquery scroll事件，支持scroll start 和 scroll stop</title>
      <link href="/2017/03/21/HTML5/HTML5%20jquery%20scroll/"/>
      <url>/2017/03/21/HTML5/HTML5%20jquery%20scroll/</url>
      
        <content type="html"><![CDATA[<p>javascript里有一个事件是滚动事件，只要拖动滚动条，就会触发事件。<br>用jquery的话，这个事件scroll 可以查看jquery api ：<a href="http://api.jquery.com/scroll/" target="_blank" rel="noopener">http://api.jquery.com/scroll/</a><br>但scroll 事件有一个缺陷，就是只能判断滚动条滚动，而不能监控滚动条停止滚动时的事件。现用jquery扩展一下scroll 事件,不多说，直接上代码实在点。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line"> </span><br><span class="line">    var special = jQuery.event.special,</span><br><span class="line">        uid1 = &apos;D&apos; + (+new Date()),</span><br><span class="line">        uid2 = &apos;D&apos; + (+new Date() + 1);</span><br><span class="line"> </span><br><span class="line">    special.scrollstart = &#123;</span><br><span class="line">        setup: function() &#123;</span><br><span class="line"> </span><br><span class="line">            var timer,</span><br><span class="line">                handler =  function(evt) &#123;</span><br><span class="line"> </span><br><span class="line">                    var _self = this,</span><br><span class="line">                        _args = arguments;</span><br><span class="line"> </span><br><span class="line">                    if (timer) &#123;</span><br><span class="line">                        clearTimeout(timer);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        evt.type = &apos;scrollstart&apos;;</span><br><span class="line">                        jQuery.event.handle.apply(_self, _args);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    timer = setTimeout( function()&#123;</span><br><span class="line">                        timer = null;</span><br><span class="line">                    &#125;, special.scrollstop.latency);</span><br><span class="line"> </span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">            jQuery(this).bind(&apos;scroll&apos;, handler).data(uid1, handler);</span><br><span class="line"> </span><br><span class="line">        &#125;,</span><br><span class="line">        teardown: function()&#123;</span><br><span class="line">            jQuery(this).unbind( &apos;scroll&apos;, jQuery(this).data(uid1) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    special.scrollstop = &#123;</span><br><span class="line">        latency: 300,</span><br><span class="line">        setup: function() &#123;</span><br><span class="line"> </span><br><span class="line">            var timer,</span><br><span class="line">                    handler = function(evt) &#123;</span><br><span class="line"> </span><br><span class="line">                    var _self = this,</span><br><span class="line">                        _args = arguments;</span><br><span class="line"> </span><br><span class="line">                    if (timer) &#123;</span><br><span class="line">                        clearTimeout(timer);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    timer = setTimeout( function()&#123;</span><br><span class="line"> </span><br><span class="line">                        timer = null;</span><br><span class="line">                        evt.type = &apos;scrollstop&apos;;</span><br><span class="line">                        jQuery.event.handle.apply(_self, _args);</span><br><span class="line"> </span><br><span class="line">                    &#125;, special.scrollstop.latency);</span><br><span class="line"> </span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">            jQuery(this).bind(&apos;scroll&apos;, handler).data(uid2, handler);</span><br><span class="line"> </span><br><span class="line">        &#125;,</span><br><span class="line">        teardown: function() &#123;</span><br><span class="line">            jQuery(this).unbind( &apos;scroll&apos;, jQuery(this).data(uid2) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果是用高级版本的jquery（如1.9）的话需要将handle改为dispatch;<br>可以将上面代码保存到一个文件，这相当于一个插件，呵呵。调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    jQuery(window).bind(&apos;scrollstart&apos;, function()&#123;</span><br><span class="line">        console.log(&quot;start&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    jQuery(window).bind(&apos;scrollstop&apos;, function(e)&#123;</span><br><span class="line">        console.log(&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery-scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - Num2</title>
      <link href="/2016/11/14/Javascript/JavaScript%20-%20Num2/"/>
      <url>/2016/11/14/Javascript/JavaScript%20-%20Num2/</url>
      
        <content type="html"><![CDATA[<p>内容概要：数组、对象条件判断以及循环。<br><a id="more"></a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。<br>可以直接访问length属性，取得Array的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];</span><br><span class="line">arr.length; // 6</span><br></pre></td></tr></table></figure></p><p>值得注意的是：直接给Array的length赋值会导致Array大小变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr.length = 6;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, undefined]</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr; // arr变为[1, 2]</span><br></pre></td></tr></table></figure></p><p>Array可以通过索引取值或赋值，<em>如果通过索引赋值，索引超过了范围，会同样引起Array大小的变化</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[5] = &apos;x&apos;;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h3><h4 id="1-indexOf-sub"><a href="#1-indexOf-sub" class="headerlink" title="1.indexOf(sub)"></a>1.indexOf(sub)</h4><p>通过indexOf()来搜索一个指定的元素的位置</p><h4 id="2-slice-index-length"><a href="#2-slice-index-length" class="headerlink" title="2.slice(index, length)"></a>2.slice(index, length)</h4><p>截取Array的部分元素，然后返回一个新的Array;<br>如果不给slice()传递任何参数，它就会从头到尾截取所有元素</p><h4 id="3-push和pop"><a href="#3-push和pop" class="headerlink" title="3.push和pop"></a>3.push和pop</h4><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉</p><h4 id="4-unshift和shift"><a href="#4-unshift和shift" class="headerlink" title="4.unshift和shift"></a>4.unshift和shift</h4><p>使用unshift()方法往Array的头部添加若干元素，shift()方法则把Array的第一个元素删掉</p><h4 id="5-sort"><a href="#5-sort" class="headerlink" title="5.sort"></a>5.sort</h4><p>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序</p><h4 id="6-reverse"><a href="#6-reverse" class="headerlink" title="6.reverse"></a>6.reverse</h4><p>reverse()把整个Array的元素调换位置</p><h4 id="7-splice"><a href="#7-splice" class="headerlink" title="7.splice"></a>7.splice</h4><p>可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;);//返回[],因为没有删除任何元素</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="8-concat"><a href="#8-concat" class="headerlink" title="8.concat"></a>8.concat</h4><p>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - Num1</title>
      <link href="/2016/11/03/Javascript/JavaScript%20-%20Num1/"/>
      <url>/2016/11/03/Javascript/JavaScript%20-%20Num1/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是世界上最流行的编程语言。<br>因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。<br><a id="more"></a></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中：</p><pre><code>&lt;script&gt;    alert(&apos;hello world&apos;);&lt;/script&gt;</code></pre><p>由<code>&lt;scrip&gt;...&lt;/script&gt;</code>包含的代码就是JavaScript代码，它将直接被浏览器执行。</p><p>第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件：</p><pre><code>&lt;head&gt;    &lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><p>这样abc.js文件就会被浏览器执行；<br>把JavaScript代码放入一个单独的.js文件中更利于维护代码，并且多个页面可以各自引用同一份.js文件。<br>值得注意的是：在同一个页面中可以引入多个.js文件，浏览器按照顺序依次执行（jQuery.js之前不能使用jQuery的语法）。</p><p>有些时候你会看到<code>&lt;script&gt;</code>标签还设置了一个type属性：<code>&lt;script type=&quot;text/javascript&quot;&gt;...&lt;/script&gt;</code>,其实这是没有必要的，因为默认的type就是JavaScript代码。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>JavaScript的语法和Java语言类似，每个语句以“;”结束，语句块用“{…}”，JavaScript并不强制要求在每个语句的结尾加“;”，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上“;”。<br>请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript不区分整数和浮点数，统一用Number表示，下面是两个比较特别的Number类型：<br>NaN;（NaN表示Not a Number，当无法计算结果时用NaN表示）<br>Infinity;（Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity）<br>2 / 0; // Infinity<br>0 / 0; // NaN</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本；</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值；</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>JavaScript允许对任意数据类型做比较：<br>false == 0; // true<br>false === 0; // false<br>要特别注意相等运算符：<br>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p><pre><code>var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];var arr = new Array(1, 2, 3); // [1, 2, 3]</code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p><pre><code>var person = {    name: &apos;Bob&apos;,    age: 20,    tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;],    city: &apos;Beijing&apos;,    hasCar: true,    zipcode: null};</code></pre><p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：</p><pre><code>var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = &apos;007&apos;; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null</code></pre><p>变量名也可以用中文，但是，请不要给自己找麻烦！！！<br>JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p><pre><code>i = 10; // i现在是全局变量</code></pre><h1 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h1><p>JavaScript的字符串就是用’’或””括起来的字符表示。<br>如果’本身也是一个字符，那就可以用””括起来。</p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用` … `表示：</p><pre><code>alert(`helloworld`);</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>要把多个字符串连接起来，可以用+号连接：</p><pre><code>var name = &apos;小明&apos;;var age = 20;var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;alert(message);</code></pre><p>如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p><pre><code>var name = &apos;小明&apos;;var age = 20;var message = `你好, ${name}, 你今年${age}岁了!`;   alert(message);</code></pre><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><p>1.字符串长度</p><pre><code>var s = &apos;Hello, world!&apos;;s.length; // 13</code></pre><p>2.获取字符串某个指定位置的字符</p><pre><code>var s = &apos;Hello, world!&apos;;s[0]; // &apos;H&apos;s[6]; // &apos; &apos;s[7]; // &apos;w&apos;s[12]; // &apos;!&apos;s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined</code></pre><p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果</p><p>3.JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p><h4 id="toUpperCase-把一个字符串全部变为大写"><a href="#toUpperCase-把一个字符串全部变为大写" class="headerlink" title="toUpperCase 把一个字符串全部变为大写"></a>toUpperCase 把一个字符串全部变为大写</h4><pre><code>var s = &apos;Hello&apos;;s.toUpperCase(); // 返回&apos;HELLO&apos;</code></pre><h4 id="toLowerCase-把一个字符串全部变为小写"><a href="#toLowerCase-把一个字符串全部变为小写" class="headerlink" title="toLowerCase 把一个字符串全部变为小写"></a>toLowerCase 把一个字符串全部变为小写</h4><pre><code>var s = &apos;Hello&apos;;var lower = s.toLowerCase(); // 返回&apos;hello&apos;并赋值给变量lower</code></pre><h4 id="indexOf-指定字符串出现的位置"><a href="#indexOf-指定字符串出现的位置" class="headerlink" title="indexOf 指定字符串出现的位置"></a>indexOf 指定字符串出现的位置</h4><pre><code>var s = &apos;hello, world&apos;;s.indexOf(&apos;world&apos;); // 返回7s.indexOf(&apos;World&apos;); // 没有找到指定的子串，返回-1</code></pre><h4 id="substring-返回指定索引区间的子串"><a href="#substring-返回指定索引区间的子串" class="headerlink" title="substring 返回指定索引区间的子串"></a>substring 返回指定索引区间的子串</h4><pre><code>var s = &apos;hello, world&apos;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;s.substring(7); // 从索引7开始到结束，返回&apos;world&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5成长之路一</title>
      <link href="/2016/08/29/HTML5/HTML5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B8%80/"/>
      <url>/2016/08/29/HTML5/HTML5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>学习一门新的编程语言，是一个循序渐进的过程！<br><a id="more"></a></p><h3 id="一、常用标签"><a href="#一、常用标签" class="headerlink" title="一、常用标签"></a>一、常用标签</h3><figure class="highlight plain"><figcaption><span>表示是一个标题```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```&lt;p&gt; 段落标签</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>水平线标签```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```&lt;br/&gt; 换行标签</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>下标```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```&lt;sup&gt; 上标</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>原样标签： 原样标签会保留空格和换行符。```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```&lt;ol&gt; &lt;li&gt; 有序的列表标签、</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span><li> 无序的列表标签。```</li></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```项目列表标签(dl dt dd)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```块标签&lt;div&gt; div标签的内容会独立占一行。</span><br></pre></td></tr></table></figure><h3 id="二、实体标签"><a href="#二、实体标签" class="headerlink" title="二、实体标签"></a>二、实体标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空格 &amp;nbsp;</span><br><span class="line">小于号 &amp;lt;</span><br><span class="line">大于号 &amp;gt;</span><br><span class="line">人民币 &amp;yen;</span><br><span class="line">版权 &amp;copy;</span><br><span class="line">商标 &amp;reg;</span><br></pre></td></tr></table></figure><h3 id="三、媒体标签"><a href="#三、媒体标签" class="headerlink" title="三、媒体标签"></a>三、媒体标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed&gt;&lt;/embed&gt;</span><br><span class="line">hidden ： 设置隐藏插件是否隐藏。</span><br><span class="line">src ：用于指定音乐的路径</span><br><span class="line">&lt;embed src=&quot;1.mp3&quot; &gt;&lt;/embed&gt;</span><br><span class="line">&lt;marquee&gt; 飘动标签direction : 指定飘动的方向</span><br><span class="line">scrollamount : 指定飘动的速度。</span><br><span class="line">loop :指定飘动的次数</span><br></pre></td></tr></table></figure><h3 id="四、超链接标签"><a href="#四、超链接标签" class="headerlink" title="四、超链接标签"></a>四、超链接标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt; 超链接标签</span><br><span class="line">a标签常用的属性：</span><br><span class="line">href : 用于指定链接的资源</span><br><span class="line">target: 设置打开新资源的目标。</span><br><span class="line">_Blank 在独立的窗口上打开新资源</span><br><span class="line">_self 在当前窗口打开新资源</span><br><span class="line">file: file协议（文件协议）这种协议主要是用于搜索本地机器的资源文件的。</span><br><span class="line">格式：</span><br><span class="line">file:///f:/美女/1.jpg</span><br><span class="line">邮件 的协议： mailTo迅雷的协议： thunder</span><br><span class="line">超链接标签的作用：</span><br><span class="line">1. 可以用于链接资源。</span><br><span class="line">2. 锚点点位.</span><br><span class="line">1. 首先编写一个锚点 锚点的格式： &lt;a name=&quot;锚点名字&quot;&gt; 数据&lt;/a&gt;</span><br><span class="line">2. 使用a标签 的herf属性连接到锚点出。 href=”#锚点的名字“</span><br></pre></td></tr></table></figure><h3 id="五、图片标签"><a href="#五、图片标签" class="headerlink" title="五、图片标签"></a>五、图片标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img标签常用的属性:</span><br><span class="line">width： 设置图片宽度</span><br><span class="line">height 设置图片高度</span><br><span class="line">alt: 如果图片资源无法找到，那么就显示对应的文字对图片进行说明。</span><br></pre></td></tr></table></figure><h3 id="六、表格标签"><a href="#六、表格标签" class="headerlink" title="六、表格标签"></a>六、表格标签</h3><p>表格使用到的标签：</p><figure class="highlight plain"><figcaption><span>表格</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt; 行</span><br><span class="line">&lt;td&gt; 单元格</span><br><span class="line">&lt;th&gt; 表头 默认的样式是居中，加粗。</span><br><span class="line">&lt;caption&gt; 表格的标题</span><br><span class="line">表格常用的属性：</span><br><span class="line">border 设置表格的边框</span><br><span class="line">width : 设置表格的宽度</span><br><span class="line">height: 设置表格的高度的。</span><br><span class="line">colspan: 设置单元格占据指定的列数。</span><br><span class="line">rowspan : 设置单元格占据指定的行数。</span><br><span class="line">&lt;thead&gt; 标签用于组合 HTML 表格的表头内容。</span><br><span class="line">&lt;thead&gt; 元素应该与&lt;tbody&gt;和&lt;tfoot&gt;元素结合起来使用，用来规定表格的各个部分（表头、主体、页脚）。</span><br><span class="line">通过使用这些元素，使浏览器有能力支持独立于表格表头和表格页脚的表格主体滚动。当包含多个页面的长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</span><br><span class="line">&lt;thead&gt; 标签必须被用在以下情境中：作为 &lt;table&gt; 元素的子元素，出现在 &lt;caption&gt;、&lt;colgroup&gt; 元素之后，&lt;tbody&gt;、 &lt;tfoot&gt; 和 &lt;tr&gt; 元素之前。</span><br></pre></td></tr></table></figure><h3 id="七、表单标签"><a href="#七、表单标签" class="headerlink" title="七、表单标签"></a>七、表单标签</h3><p><code>表单标签： 表单标签的作用是用于提交数据给服务器的表单标签的根标签是&lt;form&gt;标签常用的属性action: 该属性是用于指定提交数据的地址。method： 指定表单的提交方式。get : 默认使用的提交方式。 提交的数据会显示在地址栏上。post ： 提交的数据不会显示在地址栏上。注意： 表单项的数据如果需要提交到服务器上面，那么表单项必须要有name的属性值</code></p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Podspec-上传个人代码至CocoaPods官方库</title>
      <link href="/2016/08/24/iOS/Podspec-%E4%B8%8A%E4%BC%A0%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E8%87%B3Cocoapod%E5%AE%98%E6%96%B9%E5%BA%93/"/>
      <url>/2016/08/24/iOS/Podspec-%E4%B8%8A%E4%BC%A0%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E8%87%B3Cocoapod%E5%AE%98%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Cocoapods作为iOS开发的包管理器，给我们的开发带来了极大的便利，而且越来越多的第三方类库支持Pod，可以通过Pod傻瓜式的集成到自己的工程中，那么问题来了，我自己也有一系列的小工具类，怎么让它也支持pod集成进而让其他朋友方便的使用呢?<br><a id="more"></a></p><h3 id="1-上传项目至github-在此不作赘述"><a href="#1-上传项目至github-在此不作赘述" class="headerlink" title="1.上传项目至github(在此不作赘述)"></a>1.上传项目至github(在此不作赘述)</h3><h3 id="2-cd到该项目目录，创建podspec文件"><a href="#2-cd到该项目目录，创建podspec文件" class="headerlink" title="2.cd到该项目目录，创建podspec文件"></a>2.cd到该项目目录，创建podspec文件</h3><p>$ pod spec create [项目名]</p><h3 id="3-编辑Podspec文件"><a href="#3-编辑Podspec文件" class="headerlink" title="3.编辑Podspec文件"></a>3.编辑Podspec文件</h3><p>附上我的Podspec文件，供大家参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">    s.name         = &apos;AJDownload&apos;</span><br><span class="line">    s.version      = &apos;1.0.0&apos;</span><br><span class="line">    s.summary      = &apos;Download manager based on AFNetworking 3.0&apos;</span><br><span class="line">    s.homepage     = &apos;https://github.com/gxbxgithub/AJDownload&apos;</span><br><span class="line">    s.license      = &apos;MIT&apos;</span><br><span class="line">    s.authors      = &#123; &apos;guoxb&apos; =&gt; &apos;gxbxemail@163.com&apos; &#125;</span><br><span class="line">    s.platform     = :ios, &apos;8.0&apos;</span><br><span class="line">    s.source       = &#123; :git =&gt; &apos;https://github.com/gxbxgithub/AJDownload.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">    s.source_files = &apos;AJDownload/**/*.&#123;h,m&#125;&apos;</span><br><span class="line">    s.framework    = &apos;UIKit&apos;</span><br><span class="line">    s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</span><br><span class="line">    s.requires_arc = true</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="4-验证Podspec文件"><a href="#4-验证Podspec文件" class="headerlink" title="4.验证Podspec文件"></a>4.验证Podspec文件</h3><p>$ pod lib lint</p><h3 id="5-打tag上传Podspec"><a href="#5-打tag上传Podspec" class="headerlink" title="5.打tag上传Podspec"></a>5.打tag上传Podspec</h3><p>$ git tag -m “first commit” “0.0.1”</p><p>$ git push –tags</p><h3 id="6-最后使用pod-trunk-推送到CocoaPod官方库，只是此操作需要注册，注册指令："><a href="#6-最后使用pod-trunk-推送到CocoaPod官方库，只是此操作需要注册，注册指令：" class="headerlink" title="6.最后使用pod trunk 推送到CocoaPod官方库，只是此操作需要注册，注册指令："></a>6.最后使用pod trunk 推送到CocoaPod官方库，只是此操作需要注册，注册指令：</h3><p>$ pod trunk register <a href="mailto:gxbxemail@163.com" target="_blank" rel="noopener">gxbxemail@163.com</a></p><h3 id="7-如果已经注册，请忽略第6步；推送到CocoaPod"><a href="#7-如果已经注册，请忽略第6步；推送到CocoaPod" class="headerlink" title="7.如果已经注册，请忽略第6步；推送到CocoaPod"></a>7.如果已经注册，请忽略第6步；推送到CocoaPod</h3><p>$ pod trunk push AJDownload.podspec</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
            <tag> Podspec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS9开放的新API--Spotlight使用指南</title>
      <link href="/2016/05/04/iOS/ios9%E5%BC%80%E6%94%BE%E7%9A%84%E6%96%B0api--spotlight%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2016/05/04/iOS/ios9%E5%BC%80%E6%94%BE%E7%9A%84%E6%96%B0api--spotlight%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>作为苹果iOS9的重要特性之一，Spotlight搜索如今重新回到主界面最左侧（同样支持主界面下滑呼出），通过API的支持，还带来了全新的Universal Search通用搜索功能，除了网络以及系统本身内容之外，还能直接搜索第三方应用内的相关内容。下面我们就来详细研究下Spotlight<br><a id="more"></a></p><h3 id="1-Spotloight是什么"><a href="#1-Spotloight是什么" class="headerlink" title="1.Spotloight是什么?"></a>1.Spotloight是什么?</h3><p>　　Spotlight在iOS9上做了一些新的改进, 也就是开放了一些新的API, 通过Core Spotlight Framework你可以在你的app中集成Spotlight。集成Spotlight的App可以在Spotlight中搜索App的内容，并且通过内容打开相关页面。</p><h3 id="2-如何集成Spotlight"><a href="#2-如何集成Spotlight" class="headerlink" title="2.如何集成Spotlight"></a>2.如何集成Spotlight</h3><h6 id="a-添加所需要的框架"><a href="#a-添加所需要的框架" class="headerlink" title="a.添加所需要的框架"></a>a.添加所需要的框架</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000</span><br><span class="line">#import &lt;CoreSpotlight/CoreSpotlight.h&gt;</span><br><span class="line">#import &lt;MobileCoreServices/MobileCoreServices.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>注,很多APP都是支持iOS9以下的,因此加入#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000,可以解决iOS9以下设备运行崩溃的问题</p><h6 id="b-创建CSSearchableItemAttributeSet-对象"><a href="#b-创建CSSearchableItemAttributeSet-对象" class="headerlink" title="b.创建CSSearchableItemAttributeSet 对象"></a>b.创建CSSearchableItemAttributeSet 对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSSearchableItemAttributeSet *attributeSet = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:(NSString *)kUTTypeImage];</span><br><span class="line">    attributeSet.title = spotlightTitle;// 标题</span><br><span class="line">    attributeSet.keywords = keywords;// 关键字,NSArray格式</span><br><span class="line">    attributeSet.contentDescription = spotlightDesc;// 描述</span><br><span class="line">    attributeSet.thumbnailData = photo;// 图标, NSData格式</span><br><span class="line">　　// 把图片转换成NSData的方法</span><br><span class="line">　　UIImagePNGRepresentation([UIImage imageNamed:@&quot;xxx.png&quot;]</span><br></pre></td></tr></table></figure><h6 id="c-创建可检索条目CSSearchableItem"><a href="#c-创建可检索条目CSSearchableItem" class="headerlink" title="c.创建可检索条目CSSearchableItem"></a>c.创建可检索条目CSSearchableItem</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// spotlightInfo 可以作为一些数据传递给接受的地方</span><br><span class="line">// domainId      id,通过这个id来判断是哪个spotlight</span><br><span class="line">CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:spotlightInfo domainIdentifier:domainId attributeSet:attributeSet];</span><br></pre></td></tr></table></figure><h6 id="d-添加检索入口"><a href="#d-添加检索入口" class="headerlink" title="d.添加检索入口"></a>d.添加检索入口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:@[item] completionHandler:^(NSError * error) &#123;</span><br><span class="line">     if (error) &#123;</span><br><span class="line">        NSLog(@&quot;indexSearchableItems Error:%@&quot;,error.localizedDescription);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h6 id="完整代码"><a href="#完整代码" class="headerlink" title="========完整代码========"></a>========完整代码========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(void)insertSearchableItem:(NSData *)photo spotlightTitle:(NSString *)spotlightTitle description:(NSString *)spotlightDesc keywords:(NSArray *)keywords spotlightInfo:(NSString *)spotlightInfo domainId:(NSString *)domainId &#123;</span><br><span class="line">    CSSearchableItemAttributeSet *attributeSet = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:(NSString *)kUTTypeImage];</span><br><span class="line">    </span><br><span class="line">    attributeSet.title = spotlightTitle;                // 标题</span><br><span class="line">    attributeSet.keywords = keywords;                   // 关键字,NSArray格式</span><br><span class="line">    attributeSet.contentDescription = spotlightDesc;    // 描述</span><br><span class="line">    attributeSet.thumbnailData = photo;                 // 图标, NSData格式</span><br><span class="line">    </span><br><span class="line">    // spotlightInfo 可以作为一些数据传递给接受的地方</span><br><span class="line">    // domainId      id,通过这个id来判断是哪个spotlight</span><br><span class="line">    CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:spotlightInfo domainIdentifier:domainId attributeSet:attributeSet];</span><br><span class="line">    </span><br><span class="line">    [[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:@[item] completionHandler:^(NSError * error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;indexSearchableItems Error:%@&quot;,error.localizedDescription);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="加载本地图片的使用方法"><a href="#加载本地图片的使用方法" class="headerlink" title="========加载本地图片的使用方法========"></a>========加载本地图片的使用方法========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self insertSearchableItem:UIImagePNGRepresentation([UIImage imageNamed:@&quot;xxx.png&quot;]) spotlightTitle:@&quot;等风来&quot; description:@&quot;等风来描述&quot; keywords:@[@&quot;鲍鲸鲸&quot;,@&quot;大丽花&quot;] spotlightInfo:@&quot;传递过去的值&quot; domainId:@&quot;com.wb.spotlight&quot;];</span><br></pre></td></tr></table></figure><h6 id="加载网络图片的使用方法"><a href="#加载网络图片的使用方法" class="headerlink" title="========加载网络图片的使用方法========"></a>========加载网络图片的使用方法========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSData * data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&quot;http://hiphotos.baidu.com/doc/pic/item/eaf81a4c510fd9f905f61934262dd42a2934a48e.jpg&quot;]];</span><br><span class="line">        [self insertSearchableItem:data spotlightTitle:@&quot;等风来&quot; description:@&quot;等风来描述&quot; keywords:@[@&quot;鲍鲸鲸&quot;,@&quot;大丽花&quot;] spotlightInfo:@&quot;传递过去的值&quot; domainId:@&quot;com.wb.spotlight&quot;];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h6 id="删除所有spotlight的方法"><a href="#删除所有spotlight的方法" class="headerlink" title="========删除所有spotlight的方法========"></a>========删除所有spotlight的方法========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[CSSearchableIndex defaultSearchableIndex] deleteAllSearchableItemsWithCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, error.localizedDescription);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h6 id="删除指定的spotlight的方法"><a href="#删除指定的spotlight的方法" class="headerlink" title="========删除指定的spotlight的方法========"></a>========删除指定的spotlight的方法========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[CSSearchableIndex defaultSearchableIndex] deleteSearchableItemsWithDomainIdentifiers:@&quot;domainId&quot; completionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">if (error) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, error.localizedDescription);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h6 id="点击spotlight后的响应方法"><a href="#点击spotlight后的响应方法" class="headerlink" title="========点击spotlight后的响应方法========"></a>========点击spotlight后的响应方法========</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler &#123;</span><br><span class="line">if ([[userActivity activityType] isEqualToString:CSSearchableItemActionType]) &#123;</span><br><span class="line">NSString *uniqueIdentifier = [userActivity.userInfo objectForKey:CSSearchableItemActivityIdentifier];</span><br><span class="line">// 接受事先定义好的数值,如果是多个参数可以使用把json转成string传递过来,接受后把string在转换为json</span><br><span class="line">NSLog(@&quot;传递过来的值%@&quot;, uniqueIdentifier);</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000</span><br><span class="line">　　// 相关spotlight的方法等</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// Spotlight支持iOS9以上设备运行,对与低版本的设备需加入这个防止崩溃问题</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spotlight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题/技巧大整理</title>
      <link href="/2016/02/09/iOS/%E9%97%AE%E9%A2%98:%E6%8A%80%E5%B7%A7%E5%A4%A7%E6%95%B4%E7%90%86/"/>
      <url>/2016/02/09/iOS/%E9%97%AE%E9%A2%98:%E6%8A%80%E5%B7%A7%E5%A4%A7%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近一直忙于项目的开发，以下是开发项目中一些小问题和小技巧，一直写在笔记里，没时间整理，今天有空作个整理…<br><a id="more"></a></p><h3 id="1-获取app信息"><a href="#1-获取app信息" class="headerlink" title="1.获取app信息"></a>1.获取app信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];</span><br><span class="line"></span><br><span class="line">    // app名称</span><br><span class="line">    NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleName&quot;];</span><br><span class="line">    </span><br><span class="line">    // app版本</span><br><span class="line">    NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br><span class="line">    </span><br><span class="line">    // app build版本</span><br><span class="line">    NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];</span><br></pre></td></tr></table></figure><h3 id="2-苹果系统代码汉字转拼音"><a href="#2-苹果系统代码汉字转拼音" class="headerlink" title="2.苹果系统代码汉字转拼音"></a>2.苹果系统代码汉字转拼音</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString *hanziText = @&quot;我是中国人&quot;;  </span><br><span class="line">if ([hanziText length]) &#123;  </span><br><span class="line">    NSMutableString *ms = [[NSMutableString alloc] initWithString:hanziText];  </span><br><span class="line">    if (CFStringTransform((__bridge CFMutableStringRef)ms, 0, kCFStringTransformMandarinLatin, NO)) &#123;  </span><br><span class="line">        NSLog(@&quot;pinyin: %@&quot;, ms);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (CFStringTransform((__bridge CFMutableStringRef)ms, 0, kCFStringTransformStripDiacritics, NO)) &#123;  </span><br><span class="line">        NSLog(@&quot;pinyin: %@&quot;, ms);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-传入色值字符串，转换为十六进制色值"><a href="#3-传入色值字符串，转换为十六进制色值" class="headerlink" title="3.传入色值字符串，转换为十六进制色值"></a>3.传入色值字符串，转换为十六进制色值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;十六进制色值&quot;;</span><br><span class="line">1.//先以16为参数告诉strtoul字符串参数表示16进制数字，然后使用0 x%X转为数字类型</span><br><span class="line">unsigned long red = strtoul([str UTF8String],0,16);</span><br><span class="line">2.//strtoul如果传入的字符开头是“0 x”,那么第三个参数是0，也是会转为十六进制的,这样写也可以：</span><br><span class="line">unsigned long red = strtoul([@&quot;0 x6587&quot; UTF8String],0,0);</span><br><span class="line">NSLog(@&quot;转换完的数字为：%lx&quot;,red);</span><br></pre></td></tr></table></figure><h3 id="4-统计项目代码行数"><a href="#4-统计项目代码行数" class="headerlink" title="4.统计项目代码行数"></a>4.统计项目代码行数</h3><p>1、打开终端</p><p>2、cd 进入项目根目录</p><p>3、输入命令 find . “(“ -name “<em>.m” -or -name “</em>.mm” -or -name “<em>.cpp” -or -name “</em>.h” -or -name “*.rss” “)” -print | xargs wc -l</p><p>4、回车出结果。</p><h3 id="5-改变UIImage图片颜色"><a href="#5-改变UIImage图片颜色" class="headerlink" title="5.改变UIImage图片颜色"></a>5.改变UIImage图片颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIImage *gridImage = [UIImage imageNamed:@&quot;camera-grid&quot;];</span><br><span class="line">        gridImage = [gridImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];</span><br><span class="line">UIImageView *gridCameraView = [[UIImageView alloc] initWithImage:gridImage];</span><br><span class="line">        [gridCameraView setTintColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure><h3 id="6-程序运行过程中隐藏状态栏"><a href="#6-程序运行过程中隐藏状态栏" class="headerlink" title="6.程序运行过程中隐藏状态栏"></a>6.程序运行过程中隐藏状态栏</h3><p>在Info.plist中增加 Status bar is initially hidden一行,选择为 YES, 还需增加 View controller-based status bar appearance 一行,选择为 NO。<br><code>[[UIApplication sharedApplication]setStatusBarHidden:NO];</code></p><h3 id="7-模糊效果UIVisualEffectView"><a href="#7-模糊效果UIVisualEffectView" class="headerlink" title="7.模糊效果UIVisualEffectView"></a>7.模糊效果UIVisualEffectView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIVisualEffectView *bgView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]];</span><br><span class="line">bgView.alpha = 0.9f;</span><br><span class="line">bgView.frame = CGRectMake(0, 0, WIDTH, HEIGHT);</span><br><span class="line">bgView.layer.cornerRadius = BALL_RADIUS / 2;</span><br><span class="line">bgView.clipsToBounds = YES;</span><br><span class="line">[self addSubview:bgView];</span><br></pre></td></tr></table></figure><h3 id="8-获取当前界面"><a href="#8-获取当前界面" class="headerlink" title="8.获取当前界面"></a>8.获取当前界面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//获取当前屏幕显示的viewcontroller</span><br><span class="line">- (UIViewController *)getCurrentVC</span><br><span class="line">&#123;</span><br><span class="line">    UIViewController *result = nil;</span><br><span class="line">    UIWindow * window = [[UIApplication sharedApplication] keyWindow];</span><br><span class="line">    if (window.windowLevel != UIWindowLevelNormal)&#123;</span><br><span class="line">       NSArray *windows = [[UIApplication sharedApplication] windows];</span><br><span class="line">       for(UIWindow * tmpWin in windows)&#123;</span><br><span class="line">           if (tmpWin.windowLevel == UIWindowLevelNormal)</span><br><span class="line">           &#123;</span><br><span class="line">              window = tmpWin;</span><br><span class="line">              break;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UIView *frontView = [[window subviews] objectAtIndex:0];</span><br><span class="line">    id nextResponder = [frontView nextResponder];</span><br><span class="line">    if ([nextResponder isKindOfClass:[UIViewController class]])  </span><br><span class="line">        result = nextResponder;  </span><br><span class="line">    else </span><br><span class="line">        result = window.rootViewController;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-判断用户是否允许推送通知（iOS7-iOS8）"><a href="#9-判断用户是否允许推送通知（iOS7-iOS8）" class="headerlink" title="9.判断用户是否允许推送通知（iOS7/iOS8）"></a>9.判断用户是否允许推送通知（iOS7/iOS8）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isAllowedNotification &#123;</span><br><span class="line">    //iOS8 check if user allow notification</span><br><span class="line">    if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123;// system is iOS8</span><br><span class="line">        UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings];</span><br><span class="line">        if (UIUserNotificationTypeNone != setting.types) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;//iOS7</span><br><span class="line">        UIRemoteNotificationType type = [[UIApplication sharedApplication] enabledRemoteNotificationTypes];</span><br><span class="line">        if(UIRemoteNotificationTypeNone != type)</span><br><span class="line">            return YES;</span><br><span class="line">        //        int typeBadge = (type &amp; UIRemoteNotificationTypeBadge);</span><br><span class="line">//        int typeSound = (type &amp; UIRemoteNotificationTypeSound);</span><br><span class="line">//        int typeAlert = (type &amp; UIRemoteNotificationTypeAlert);</span><br><span class="line">//        BOOL ret =  !typeBadge || !typeSound || !typeAlert;</span><br><span class="line">//        yn = !ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS问题-技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你的APP更换皮肤、主题</title>
      <link href="/2015/07/18/iOS/%E4%B8%BA%E4%BD%A0%E7%9A%84APP%E6%9B%B4%E6%8D%A2%E7%9A%AE%E8%82%A4%E3%80%81%E4%B8%BB%E9%A2%98/"/>
      <url>/2015/07/18/iOS/%E4%B8%BA%E4%BD%A0%E7%9A%84APP%E6%9B%B4%E6%8D%A2%E7%9A%AE%E8%82%A4%E3%80%81%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在项目里面有个模块涉及到主题设置，在网上学习了很多篇文章，这篇文章主要谈一下个人的做法。</p><p>大致的步骤如下：</p><ul><li>整个应用依赖于一个主题管理器，主题管理器根据当前的主题配置，加载不同主题文件夹下的主题</li><li>在需要更换主题的地方创建统一通知【我的做法是：例如更换所有UILabel的字体颜色，创建UILabel基类，所有涉及主题切换的label都继承UILabel基类，在基类中创建通知】</li><li>切换主题，发送统一通知更换主题<a id="more"></a><h3 id="1-主题管理器"><a href="#1-主题管理器" class="headerlink" title="1.主题管理器"></a>1.主题管理器</h3><img src="http://img.haoyunbang.cn/app/2016-08-23/3849E26F-78C0-4B9A-BEFF-5C0666D6C1DB/509qdl0t.jpg@280w" alt="theme_manager"></li></ul><p>这是主题管理器文件夹下所有涉及主题切换的基类，ThemeManager为管理器</p><p>ThemeManager被构建为是单例，在实例初始化的时候，同时实例化主题的相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (ThemeManager*)sharedInstance&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        themeManager = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return themeManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> ** 初始化</span><br><span class="line"> **/</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">    //设置默认主题</span><br><span class="line">        [self makeDefaultTheme];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-主题设置的主要代码"><a href="#2-主题设置的主要代码" class="headerlink" title="2.主题设置的主要代码"></a>2.主题设置的主要代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> ** 设置主题</span><br><span class="line"> **/</span><br><span class="line">-(void)makeDefaultTheme&#123;</span><br><span class="line">    /**</span><br><span class="line">     ** 创建Theme文件夹在Cache文件夹下，用于存放主题文件夹</span><br><span class="line">     **/</span><br><span class="line">    NSString *themePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:@&quot;Theme&quot;];</span><br><span class="line">    //文件管理器</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    if (![fileManager fileExistsAtPath:themePath]) &#123;</span><br><span class="line">        [fileManager createDirectoryAtPath:themePath withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;themePath = %@&quot;,themePath);</span><br><span class="line">    //主题基本路径</span><br><span class="line">    self.themeBasePath = themePath;</span><br><span class="line">    /**</span><br><span class="line">     ** 设置主题</span><br><span class="line">     **/</span><br><span class="line">    NSString *themeName = [[Config Instance] getThemeName];</span><br><span class="line">//    themeName = @&quot;ThemeDefault&quot;;</span><br><span class="line">    NSString *plistPath = @&quot;&quot;;</span><br><span class="line">    if ([themeName isEqualToString:@&quot;ThemeDefault&quot;]) &#123;</span><br><span class="line">        plistPath = [[NSBundle mainBundle] pathForResource:@&quot;ThemeDefault&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        plistPath = [[themePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;skin_%@&quot;,[[Config Instance] getThemeId]]] stringByAppendingPathComponent:@&quot;theme.plist&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dictionary = [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    [userDefaults setObject:dictionary forKey:@&quot;kAllColorDict&quot;];</span><br><span class="line">    [userDefaults synchronize];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     ** 初始化本类属性</span><br><span class="line">     **/</span><br><span class="line">    //主题名称</span><br><span class="line">    self.themeName = themeName;</span><br><span class="line">    //主题路径</span><br><span class="line">    self.themePath = [themePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;skin_%@&quot;,[[Config Instance] getThemeId]]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码，会有一个关于主题配置的.plish文件存在本地，之后发送通知设置主题即可。。。</p><h3 id="3-附上基类代码"><a href="#3-附上基类代码" class="headerlink" title="3.附上基类代码"></a>3.附上基类代码</h3><p><code>ThemeLabel.m文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1.alloc init之后执行该方法，注册通知设置默认主题皮肤</span><br><span class="line">-(void)makeThemeLabelColor:(ThemeLabelColor *)color&#123;</span><br><span class="line">    self.labelColor = color;</span><br><span class="line">    [self loadLabelColor];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(themeNotification:) name:kThemeDidChangeNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.更换主题会执行该方法，改变主题</span><br><span class="line">-(void)themeNotification:(NSNotification *)notification&#123;</span><br><span class="line">    [self loadLabelColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.更换主题操作</span><br><span class="line">-(void)loadLabelColor&#123;</span><br><span class="line">    //size</span><br><span class="line">    if (self.labelColor == ThemeLabelSize) &#123;</span><br><span class="line">        self.frame = CGRectMake(0, 0, SCREENWIDTH, 0);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //header</span><br><span class="line">    if (self.labelColor == ThemeLabelHeaderBgColor) &#123;</span><br><span class="line">        self.backgroundColor = kMyThemeColor(kBgColor);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //color</span><br><span class="line">    UIColor *textColor = [UIColor whiteColor];</span><br><span class="line">    if (self.labelColor == ThemeLabelTopTitleColor) &#123;</span><br><span class="line">        textColor = kMyThemeColor(kTopTitileColor);</span><br><span class="line">    &#125;else if (self.labelColor == ThemeLabelCreditErrorColor)&#123;</span><br><span class="line">        textColor = kMyThemeColor(kCreditErrorColor);</span><br><span class="line">    &#125;</span><br><span class="line">    self.textColor = textColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【ps：以上是我在项目中更换主题皮肤的简单操作，需求比较简单，更换颜色就行】</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-App皮肤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods使用步骤</title>
      <link href="/2015/04/17/iOS/CocoaPods%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/"/>
      <url>/2015/04/17/iOS/CocoaPods%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="1-打开终端-输入"><a href="#1-打开终端-输入" class="headerlink" title="1.打开终端,输入"></a>1.打开终端,输入</h4><p><code>$ gem sources --remove https://rubygems.org/</code></p><p>等有反应之后再敲入以下命令</p><p><code>$ gem sources -a http://ruby.taobao.org/</code></p><p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p><p><code>$ gem sources -l</code></p><p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p><p><code>*** CURRENT SOURCES ***</code></p><p><code>http://ruby.taobao.org/</code></p><p>1.5升级gem命令：</p><p><code>$ sudo gem update —system【sudo gem install -n /usr/local/bin cocoapods --pre】</code></p><h4 id="2-安装CocoaPods-在终端输入"><a href="#2-安装CocoaPods-在终端输入" class="headerlink" title="2.安装CocoaPods,在终端输入"></a>2.安装CocoaPods,在终端输入</h4><p><code>$ sudo gem install cocoapods</code></p><h4 id="3-如果cocoaPod镜像有问题"><a href="#3-如果cocoaPod镜像有问题" class="headerlink" title="3.如果cocoaPod镜像有问题"></a>3.如果cocoaPod镜像有问题</h4><p><code>$ pod repo remove master</code></p><p><code>$ pod repo add master https://gitcafe.com/akuandev/Specs.git</code></p><p><code>$ pod repo update</code></p><h4 id="4-假设我们要在工程中导入AFNetworking类库"><a href="#4-假设我们要在工程中导入AFNetworking类库" class="headerlink" title="4.假设我们要在工程中导入AFNetworking类库."></a>4.假设我们要在工程中导入AFNetworking类库.</h4><p>为了确定AFNetworking是否支持CocoaPods,可以用CocoaPods的搜索功能验证一下。在终端中输入:</p><p><code>$ pod search AFNetworking</code></p><p>如果显示绿体字类库名,说明CocoaPods支持该类库</p><h4 id="5-现在建一个工程-叫CocoaPodsDemo"><a href="#5-现在建一个工程-叫CocoaPodsDemo" class="headerlink" title="5.现在建一个工程,叫CocoaPodsDemo"></a>5.现在建一个工程,叫CocoaPodsDemo</h4><h4 id="6-CocoaPods的工作原理是利用Podfile文件来下载我们指定的类库-每个工程只需要一个Podfile文件-但Podfile文件需要我们利用终端自行创建"><a href="#6-CocoaPods的工作原理是利用Podfile文件来下载我们指定的类库-每个工程只需要一个Podfile文件-但Podfile文件需要我们利用终端自行创建" class="headerlink" title="6.CocoaPods的工作原理是利用Podfile文件来下载我们指定的类库,每个工程只需要一个Podfile文件,但Podfile文件需要我们利用终端自行创建"></a>6.CocoaPods的工作原理是利用Podfile文件来下载我们指定的类库,每个工程只需要一个Podfile文件,但Podfile文件需要我们利用终端自行创建</h4><h4 id="7-在终端中使用cd命令进入工程所在目录-例如"><a href="#7-在终端中使用cd命令进入工程所在目录-例如" class="headerlink" title="7.在终端中使用cd命令进入工程所在目录,例如:"></a>7.在终端中使用cd命令进入工程所在目录,例如:</h4><p><code>$ cd /Users/lanouhn/Desktop/Shared/CocoaPods</code></p><h4 id="8-当前目录下-利用vim创建Podfile-在终端中输入"><a href="#8-当前目录下-利用vim创建Podfile-在终端中输入" class="headerlink" title="8.当前目录下,利用vim创建Podfile,在终端中输入:"></a>8.当前目录下,利用vim创建Podfile,在终端中输入:</h4><p><code>$ vim Podfile</code></p><h4 id="9-按【i】或【a】进入插入模式-输入以下内容"><a href="#9-按【i】或【a】进入插入模式-输入以下内容" class="headerlink" title="9.按【i】或【a】进入插入模式,输入以下内容:"></a>9.按【i】或【a】进入插入模式,输入以下内容:</h4><p><code>$ platform :ios, &#39;7.0&#39;</code></p><p><code>$ pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot;</code></p><p>(这两行内容是在AFNetworking的github页面找到的。<br>这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0)</p><p>输入完毕后,按【ESC】返回命令行模式<br>按【:】(冒号)进入末行模式,输入【wq】保存命令并退出vim</p><h4 id="10-这时你会发现工程目录中，出现一个名为Podfile的文件，而且文件内容就是刚刚输入的内容。"><a href="#10-这时你会发现工程目录中，出现一个名为Podfile的文件，而且文件内容就是刚刚输入的内容。" class="headerlink" title="10.这时你会发现工程目录中，出现一个名为Podfile的文件，而且文件内容就是刚刚输入的内容。"></a>10.这时你会发现工程目录中，出现一个名为Podfile的文件，而且文件内容就是刚刚输入的内容。</h4><p>(注意,Podfile文件应该和工程文件.xcodeproj在同一个目录下)</p><p>此时就可以利用CocoPods下载AFNetworking类库了,还是在终端中的当前工程目录下，运行以下命令:</p><p><code>$ pod install</code></p><p>(个人猜测,执行该命令后,CocoPods自动会找到该目录下的Podfile文件,下载文件内容对应的第三方类库)</p><p>[ps.最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动<br>原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：</p><p><code>pod install --verbose --no-repo-update</code></p><p><code>pod update --verbose --no-repo-update]</code></p><h4 id="11-执行完毕后-终端会出现以下信息"><a href="#11-执行完毕后-终端会出现以下信息" class="headerlink" title="11.执行完毕后,终端会出现以下信息:"></a>11.执行完毕后,终端会出现以下信息:</h4><p>EricmatoMacBook-Pro:CocoaPodsDemo ericwang</p><p>$ pod install</p><p>Analyzing dependencies</p><p>Downloading dependencies</p><p>Installing AFNetworking (2.0.2)</p><p>Generating Pods project</p><p>Integrating client project</p><p>[!] From now on use <code>CocoaPodsDemo.xcworkspace</code>.</p><p>(注意最后一句话，意思是:以后打开工程就用 CocoaPodsDemo.xcworkspace 打开,而不是之前的.xcodeproj文件)</p><h4 id="12-此时工程目录会多一个-xcworkspace文件-一个“Podfile-lock”文件和一个文件夹“Pods”"><a href="#12-此时工程目录会多一个-xcworkspace文件-一个“Podfile-lock”文件和一个文件夹“Pods”" class="headerlink" title="12.此时工程目录会多一个.xcworkspace文件,一个“Podfile.lock”文件和一个文件夹“Pods”"></a>12.此时工程目录会多一个.xcworkspace文件,一个“Podfile.lock”文件和一个文件夹“Pods”</h4><h4 id="13-点击-xcworkspace-打开工程-你会发现-AFNetwoking已经成功导入项目了"><a href="#13-点击-xcworkspace-打开工程-你会发现-AFNetwoking已经成功导入项目了" class="headerlink" title="13.点击 .xcworkspace 打开工程,你会发现,AFNetwoking已经成功导入项目了"></a>13.点击 .xcworkspace 打开工程,你会发现,AFNetwoking已经成功导入项目了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对于工程发生的变化，有几点需要说明：</span><br><span class="line"></span><br><span class="line">第三方库会被编译成静态库供我们真正的工程使用</span><br><span class="line"></span><br><span class="line">CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。</span><br><span class="line"></span><br><span class="line">我们的工程和第三方库所在的工程会由一个新生成的workspace管理</span><br><span class="line"></span><br><span class="line">为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程会被以workspace的形式组织和管理，也就是我们刚才看到的CocoaPodsTest.xcworkspace文件。</span><br><span class="line"></span><br><span class="line">原来的工程设置已经被更改了，这时候我们直接打开原来的工程文件去编译就会报错，只能使用新生成的workspace来进行项目管理。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
